

#  一.Spring Security介绍

![image-20200908225700876](imgaes/image-20200908225700876.png)

> Spring Security 的前身是 Acegi Security ，是 Spring 项目组中用来提供安全认证服务的框架。
> (https://projects.spring.io/spring-security/) Spring Security 为基于J2EE企业应用软件提供了全面安全服务。特别
> 是使用领先的J2EE解决方案-Spring框架开发的企业软件项目。人们使用Spring Security有很多种原因，不过通常吸
> 引他们的是在J2EE Servlet规范或EJB规范中找不到典型企业应用场景的解决方案。 特别要指出的是他们不能再
> WAR 或 EAR 级别进行移植。这样，如果你更换服务器环境，就要，在新的目标环境进行大量的工作，对你的应用
> 系统进行重新配 置安全。使用Spring Security 解决了这些问题，也为你提供很多有用的，完全可以指定的其他安
> 全特性。 安全包括两个主要操作。
> “认证”，是为用户建立一个他所声明的主体。主题一般式指用户，设备或可以在你系 统中执行动作的其他系
> 统。
> “授权”指的是一个用户能否在你的应用中执行某个操作，在到达授权判断之前，身份的主题已经由 身份验证
> 过程建立了。
> 这些概念是通用的，不是Spring Security特有的。在身份验证层面，Spring Security广泛支持各种身份验证模式，
> 这些验证模型绝大多数都由第三方提供，或则正在开发的有关标准机构提供的，例如 Internet Engineering Task
> Force.作为补充，Spring Security 也提供了自己的一套验证功能。
> Spring Security 目前支持认证一体化如下认证技术： HTTP BASIC authentication headers (一个基于IEFT RFC 的
> 标准) HTTP Digest authentication headers (一个基于IEFT RFC 的标准) HTTP X.509 client certificate exchange
> (一个基于IEFT RFC 的标准) LDAP (一个非常常见的跨平台认证需要做法，特别是在大环境) Form-based
> authentication (提供简单用户接口的需求) OpenID authentication Computer Associates Siteminder JA-SIG
> Central Authentication Service (CAS，这是一个流行的开源单点登录系统) Transparent authentication context
> propagation for Remote Method Invocation and HttpInvoker (一个Spring远程调用协议)



![image-20200908233804117](imgaes/image-20200908233804117.png)

​																		**Spring Security 通过11个Filter实现的**





# 二. Spring Security 入门

## 0. 重定向、转发

![image-20200909103455871](imgaes/image-20200909103455871.png)

![image-20200909114626352](imgaes/image-20200909114626352.png)

 ## 1. 导入依赖

```xml
<!--springsecurity -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
```

**导入依赖后，Security自动生效 ，启动项目时，在控制台生成密码，用户名为user，会跳转到Security自带的登录界面**



建数据库的话，复杂的需要用户--->角色----->权限三张表，两两多对多查询，还需要两张中间表，本项目只有一张用户表，不是很复杂

![image-20200909091604989](imgaes/image-20200909091604989.png)





## 2.User entity

**User 的实体类实现UserDetatils  设置账号相关设置**

```java
package com.nowcoder.community.entity;



import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;

public class User implements UserDetails {

    private int id;
    private String username;
    private String password;
    private String salt;
    private String email;
    private int type;
    private int status;
    private String activationCode;
    private String headerUrl;
    private Date createTime;

   	//getter  setter   toString........



    //  return true  账号未过期
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    //true  账号未锁定
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    //true 凭证未过期
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    //true 账号可用
    @Override
    public boolean isEnabled() {
        return true;
    }

    //返回用户具有的权限
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<GrantedAuthority> list = new ArrayList<>();
        list.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                //通过数据库中的type字段来判断用户的权限
                switch (type){
                    case 1:
                        return "ADMIN";
                    default:
                        return "USER";
                }
            }
        });
        return list;
    }
}

```



## 3. UserService

**UserService 实现 UserDetailsService**

```
可以选择其它的service实现UserDetailsService,因为该service中有根据用户名查询用户的方法,可以直接调用,故在该类实现
```





```java
package com.nowcoder.community.service;

import com.nowcoder.community.dao.UserMapper;
import com.nowcoder.community.entity.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

//可以选择其它的service实现UserDetailsService,
//因为该service中有根据用户名查询用户的方法,可以直接调用,故在该类实现
@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    public User findUserByName(String username) {
        return userMapper.selectByName(username);
    }

    //根据用户名查询用户
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return findUserByName(username);
    }
}

```



## 4.SecurityConfig

**SecurityConfig继承WebSecurity，主要实现三个configure方法。**

```java
//忽略静态资源的访问
configure(WebSecurity web)
    
//认证    
configure(AuthenticationManagerBuilder auth)
    
//授权
configure(HttpSecurity http)
```

 **概念：**

​		**认证：**

> ​	1.AuthenticationManager:  认证的核心接口
>
> 2. AuthenticationManagerBuilder:  用于构建AuthenticationManager的工具
> 3. ProviderManager : AuthenticationManager接口的默认实现类
>
> ​	4.AuthenticationProvider : ProviderManager持有一组AuthenticationProvider，每个AuthenticationProvider负责一种认证
>
> ​	5.委托模式: ProviderManager将认证委托给了AuthenticationProvider
>
> 6. Authentication: 用于分装认证认证信息的接口,不同的实现类,代表不同类型的认证信息
>
> 
>
> 







```java
package com.nowcoder.community.config;

import com.nowcoder.community.entity.User;
import com.nowcoder.community.service.UserService;
import com.nowcoder.community.util.CommunityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;
import org.springframework.security.web.authentication.rememberme.InMemoryTokenRepositoryImpl;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    //注入该类的原因时因为该类实现了UserDetailService
    @Autowired
    private UserService userService;

    //忽略静态资源的访问
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/resources/**");
    }

    //认证
    //AuthenticationManager:  认证的核心接口
    //AuthenticationManagerBuilder： 用于构建AuthenticationManager的工具
    //ProviderManager:  AuthenticationManager接口的默认实现类
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        //内置的认证规则                       密码加密(加密方式(盐))
        //auth.userDetailsService(userService).passwordEncoder(new Pbkdf2PasswordEncoder("12345"));由于该项目中采用md5加密已经加密所以不采用内置规则

        //自定义认证规则
        //AuthenticationProvider : ProviderManager持有一组AuthenticationProvider
        //每个AuthenticationProvider负责一种认证
        //委托模式: ProviderManager将认证委托给了AuthenticationProvider
        auth.authenticationProvider(new AuthenticationProvider() {
            //Authentication: 用于分装认证认证信息的接口,不同的实现类,代表不同类型的认证信息
            @Override
            public Authentication authenticate(Authentication authentication) throws AuthenticationException {
                String username = authentication.getName();
                String password = (String) authentication.getCredentials();

                User user = userService.findUserByName(username);
                if (user == null){
                    throw new UsernameNotFoundException("账号不存在");
                }
                password = CommunityUtil.md5(password + user.getSalt());
                if (!user.getPassword().equals(password)){
                    throw new BadCredentialsException("密码不正确");
                }

                //UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)
                // principal:主要信息; credentials:证书;authorities:权限
                return new UsernamePasswordAuthenticationToken(user,user.getPassword(),user.getAuthorities());
            }

            //返回当前AuthenticationProvider接口支持的哪种认证类型
            @Override
            public boolean supports(Class<?> aClass) {
                //UsernamePasswordAuthenticationToken : Authentication接口的常用实现类
                return UsernamePasswordAuthenticationToken.class.equals(aClass);
            }
        });
    }


    //授权
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //登录相关的配置
        http.formLogin()
                .loginPage("/loginpage")  //RequestMapping路径
                .loginProcessingUrl("/login")  //登录提交表单的action路径
            	//成功跳转页面
                .successHandler(new AuthenticationSuccessHandler() {
                    @Override
                    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                        response.sendRedirect(request.getContextPath() + "/index");

                    }
                })
            	//失败跳转页面
                .failureHandler(new AuthenticationFailureHandler() {
                    @Override
                    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
                        request.setAttribute("error",e.getMessage());
                        request.getRequestDispatcher("/loginpage").forward(request,response);
                    }
                });

        //退出相关配置
        http.logout()
                .logoutUrl("/logout")
                .logoutSuccessHandler(new LogoutSuccessHandler() {
                    @Override
                    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                       response.sendRedirect(request.getContextPath() + "/index");
                    }
                });

        //授权设置
        http.authorizeRequests()
                .antMatchers("/letter").hasAnyAuthority("USER","ADMIN")//letter页面访问的权限
                .antMatchers("/admin").hasAnyAuthority("ADMIN")//admin页面访问的权限
                .and().exceptionHandling().accessDeniedPage("/denied");//访问失败跳转的页面


        //自定义Filter,处理验证码,在用户名密码校验前执行
        http.addFilterBefore(new Filter() {
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                HttpServletRequest request = (HttpServletRequest) servletRequest;
                HttpServletResponse response = (HttpServletResponse) servletResponse;
                //当前访问路径时login时
                if (request.getServletPath().equals("/login")){
                    String verifyCode = request.getParameter("verifyCode");
                    //这里为了演示前台没有生成验证码,并将验证码固定为1234
                    if (verifyCode == null || !verifyCode.equalsIgnoreCase("1234")){
                        request.setAttribute("error","验证码错误");
                        request.getRequestDispatcher("/loginpage").forward(request,response);
                        return;
                    }

                }
                //让请求继续向下执行
                filterChain.doFilter(request,response);
            }
        },UsernamePasswordAuthenticationFilter.class);



        //记住我
        http.rememberMe()
                .tokenRepository(new InMemoryTokenRepositoryImpl())//将用户存到内存中
                .tokenValiditySeconds(3600 * 24)//过期事件
                .userDetailsService(userService);//指定userDetailsService
    }
}

```



## 5.UserController

**用户认证成功后，将用户的信息存放到SecurityContextHolder中**

```java
package com.nowcoder.community.controller;

import com.nowcoder.community.entity.User;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class HomeController {

    @RequestMapping(path = "/index", method = RequestMethod.GET)
    public String getIndexPage(Model model) {
        //认证成功后,结果会通过SecurityContextHolder存入SecurityContext中
        Object obj = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        if (obj instanceof User){
            model.addAttribute("loginUser",obj);
        }
        return "/index";
    }

    
}

```



# 三、权限控制--实战

**登录检查**

​			--之前采用拦截器实现了登录检查，这是简单的权限管理方案，现在将其废弃（LoginRequiredInterceptor 自定义注解拦截器）

**授权配置**

​			--对当前系统内包含的所有的请求，分配访问权限（普通用户、版主、管理员）

**认证方案**

​			--由于我们的登录，退出功能已经写好，需要绕过Security认证流程，采用系统原来的认证方案



**（1）只用配置过滤静态资源和授权，认证方案用原来的登录功能，但是在登陆的时候userservice要返回用户的权限,由于我们没有没有进行security的认证处理**

**（2）在用户登录后（在LoginTicketInterceptor中），构建用户认证的结果,并存入SecurityContextHolder,以便于Security进行授权**

**（3）.在SecurityConfig中要判断请求是否为Ajax异步请求，**

​	**(4).用户退出后，清理SecurityContextHolder存放用户的信息**

## 0.Constant 常量接口



```java
    /**
     * 权限: 普通用户
     */
    String AUTHORITY_USER = "user";

    /**
     * 权限: 管理员
     */
    String AUTHORITY_ADMIN = "admin";

    /**
     * 权限: 版主
     */
    String AUTHORITY__MODERATOR = "moderator";
```





## 1. SecurityConfig



```java
package com.justodit.config;

import com.justodit.util.Constant;
import com.justodit.util.JustDoItUtil;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@Configuration
public class SecurityConfig  extends WebSecurityConfigurerAdapter implements Constant {


    /**
     * 忽略静态资源
     * @param web
     * @throws Exception
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/resources/**");
    }

    /**
     * 授权
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(
                        "/user/setting",
                        "/user/upload",
                        "/discuss/add",
                        "/comment/add/**",
                        "/letter/**",
                        "/notice/**",
                        "like",
                        "/follow",
                        "/unfollow"
                )
                .hasAnyAuthority(
                        AUTHORITY_USER,
                        AUTHORITY_ADMIN,
                        AUTHORITY__MODERATOR
                )
                .anyRequest().permitAll()//除了以上的请求需要权限,其它的不用
                .and().csrf().disable();//禁用csrf,由于该项目的ajax请求过多,不想改,故禁用csrf

        //权限不够时的处理
        http.exceptionHandling()
                //没登陆时,怎么处理
                .authenticationEntryPoint(new AuthenticationEntryPoint() {
                    @Override
                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
                        String xRequestedWith = request.getHeader("x-requested-with");
                        //如果是AJAX请求
                        if ("XMLHttpRequest".equals(xRequestedWith)){
                            response.setContentType("application/plain;charset=utf8");//声明数据返回类型
                            PrintWriter writer = response.getWriter();
                            writer.write(JustDoItUtil.getJsonString(403,"你还没有登录"));
                        }else {
                            //不是异步
                            response.sendRedirect(request.getContextPath() + "/login");
                        }
                    }
                })
                //登录了,权限不足怎么处理
                .accessDeniedHandler(new AccessDeniedHandler() {
                    @Override
                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {
                        String xRequestedWith = request.getHeader("x-requested-with");
                        //如果是AJAX请求
                        if ("XMLHttpRequest".equals(xRequestedWith)){
                            response.setContentType("application/plain;charset=utf8");//声明数据返回类型
                            PrintWriter writer = response.getWriter();
                            writer.write(JustDoItUtil.getJsonString(403,"你没有访问次功能的权限"));
                        }else {
                            //不是异步
                            response.sendRedirect(request.getContextPath() + "/denied");
                        }
                    }
                });


        //Security底层会拦截/logout请求,进行退出处理,退出功能我们已经写好,不想用Security提供的退出
        //那么需要覆盖默认的逻辑,才能执行自己的退出代码
        http.logout().logoutUrl("/securitylogout");//这里的路径随便写的,只要项目里没有改路径就行



    }
}

```



## 2. UserService



```java
@Service
public class UserService  implements Constant {
    
//返回用户的权限
    public Collection<? extends GrantedAuthority> getAuthorities(int userId){
        User user = this.findUserById(userId);

        List<GrantedAuthority> list = new ArrayList<>();
        list.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                switch (user.getType()){
                    case 1:
                       return AUTHORITY_ADMIN;
                    case 2:
                        return AUTHORITY__MODERATOR;
                    default:
                        return AUTHORITY_USER;
                }
            }
        });
        return list;
    }
```



## 3. LoginTicketInterceptor



```java
package com.justodit.interceptor;

import com.justodit.entity.LoginTicket;
import com.justodit.entity.User;
import com.justodit.service.UserService;
import com.justodit.util.CookieUtil;
import com.justodit.util.HostHolder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Date;

@Component
public class LoginTicketInterceptor implements HandlerInterceptor {

    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //从cookie中获取凭证
        String ticket = CookieUtil.getValue(request,"ticket");
        if (ticket != null){
            //查询凭证
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            //检查凭证是否有效
            if (loginTicket!=null && loginTicket.getStatus()==0 && loginTicket.getExpired().after(new Date())){
                User user = userService.findUserById(loginTicket.getUserId());
                //在本次请求持有用户
                hostHolder.setUser(user);

                //由于我们没有没有进行security的认证处理
                //构建用户认证的结果,并存入SecurityContextHolder,以便于Security进行授权
                Authentication authentication = new UsernamePasswordAuthenticationToken(
                        user,user.getPassword(),userService.getAuthorities(user.getId()));
                SecurityContextHolder.setContext(new SecurityContextImpl(authentication));
            }
        }

        return true;
    }

    //postHandle 在模板执行之前执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        User user = hostHolder.getUser();
        if (user!= null && modelAndView!= null){
            modelAndView.addObject("loginUser",user);
        }
    }

    //清除
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        hostHolder.clear();
        SecurityContextHolder.clearContext();//清理
    }

}

```



## 4.LoginController

```java
    /**
     * 退出  将用户的登录状态设置为1  并且将SpringSecurity中的SecurityContextHolder中的用户信息清除
     * @param ticket
     * @return
     */
   @GetMapping("/logout")
   public String loginOut(@CookieValue("ticket")String ticket){
        userService.logOut(ticket);
       SecurityContextHolder.clearContext();//清楚vSecurity中的用户信息
        return "redirect:/login";
   }
```





**CSRF配置：**

​			--防止CSRF攻击的基本原理，以及表单,AJAX相关的配置

​			**某网站盗取cookie当中的凭证，模拟你的身份访问服务器，利用表单向服务器提交数据**

​			**SpringSecurity处理：  服务器返回带有表单的页面时，表单带有一个隐藏的Tocken，这样就算某网站盗取cookie，但不能盗取Tocken**

![image-20200909191544623](imgaes/image-20200909191544623.png)





![image-20200909193741862](imgaes/image-20200909193741862.png)

**如果是表单的话，Security会自动在表单加上token ，如果是异步提交用一下方式**

页面

```html
	<!--	访问改页面时,在此处生成CSRF令牌-->
	<meta name="_csrf" th:content="${_csrf.token}">
	<meta name="_csrf_header" th:content="${_csrf.headerName}">
```



AJAX

```js
$(function(){
	$("#publishBtn").click(publish);
});

function publish() {
	$("#publishModal").modal("hide");

	//发送AJAX请求之前,将CSRF令牌设置到请求的消息头中
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function (e,xhr,options) {
		xhr.setRequestHeader(header,token)
	});
    
    //获取标题和内容
	var title = $("#recipient-name").val();
	var content = $("#message-text").val();
	//发送异步请求post
	$.post({
		url:"/discuss/add",
		data:{"title":title,"content":content},
		success:function (data) {
			data = $.parseJSON(data);//将字符串转为json
			//提示框中显示返回的消息
			$("#hintBody").text(data.msg);
			//显示提示框
			$("#hintModal").modal("show");
			//2秒后自动隐藏提示框
			setTimeout(function(){
				$("#hintModal").modal("hide");
				//刷新页面
				if (data.code == 0){
					window.location.reload();
				}
			}, 2000);
		}

	});


}
```





# 四，置顶、加精、删除--Thymeleaf + Spring Security

**1.功能实现**

​		--点击置顶，修改帖子的类型

​		--点击加精，删除，修改帖子的状态



**2.权限管理**

​		--版主可以执行置顶，加精操作

​		--管理员可以执行删除操作



**3.按钮显示**

​		--版主可以看到置顶，加精按钮

​		--管理员可以看到删除按钮

## 0. 导入 thymeleaf springsecurity5

```xml
<!-- thymeleaf + springsecurity 5 -->
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId>
</dependency>
```



## 1. 功能实现

### 1.1 DiscusspostMapper 、xml

```java
@Mapper
public interface DiscussPostMapper {
    
    
    /**
     * 修改帖子的类型
      * @param id
     * @param type  0-普通; 1-置顶
     * @return
     */
    int updateType(int id,int type);

    /**
     * 修改帖子的状态
     * @param id
     * @param status  0-正常; 1-精华; 2-拉黑;
     * @return
     */
    int updateStatus(int id,int status);
    
    
}    
```



```xml
 <!--修改贴子类型  0-普通; 1-置顶  -->
    <update id="updateType">
        update discuss_post set type = #{type} where id = #{id}
    </update>

    <!-- 修改贴子状态 0-正常; 1-精华; 2-拉黑;   -->
    <update id="updateStatus">
        update discuss_post set status = #{status} where id = #{id}
    </update>
```



### 1.2 DiscussPostService

```java
@Service
public class DiscussPostService {
    /**
     * 更新贴子类型
     * @param id
     * @param type   0-普通; 1-置顶;
     * @return
     */
    public int updateType(int id,int type){
        return discussPostMapper.updateType(id,type);
    }

    /**
     * 更新贴子状态
     * @param id
     * @param status  0-正常; 1-精华; 2-拉黑
     * @return
     */
    public int updateStatus(int id,int status){
        return discussPostMapper.updateStatus(id, status);
    }
    
}    
```



### 1.3 EventConsumer

​	常量接口：

![image-20200910153631600](imgaes/image-20200910153631600.png)

消费删除贴子的消费者（ElasticSearch）

```java
//消费者
@Component
public class EventConsumer implements Constant {
    
    
    /**
     * 消费删帖事件
     */
    @KafkaListener(topics = {TOPIC_DELETE})
    public void handleDeletePost(ConsumerRecord record){
        if (record == null || record.value() == null){
            logger.error("消息的内容为空");
            return;
        }

        Event event = JSONObject.parseObject(record.value().toString(),Event.class);
        if (event == null){
            logger.error("消息格式有误");
            return;
        }

        //通过消息的id查询贴子,存放到es中
       elasticSearchService.deleteDiscussPost(event.getEntityId());


    }
```



### 1.4 DiscussPostController

置顶、加精、删除都要跟新ElasticSearch中的信息

````java
    /**
     *  置顶
     * @param id
     * @return
     */
    @PostMapping("/top")
    @ResponseBody
    public String setTop(int id){
        discussPostService.updateType(id,1);

        //将贴子同步到ElasticSearch中
        //触发发帖事件
        Event event = new Event()
                .setTopic(TOPIC_PUBLISH)
                .setUserId(hostHolder.getUser().getId())//触发者
                .setEntityType(ENTITY_TYPE_POST)
                .setEntityId(id);

        eventProducer.fireEvent(event);
        return JustDoItUtil.getJsonString(0);//0表示成功
    }


    /**
     *  加精
     * @param id
     * @return
     */
    @PostMapping("/wonderful")
    @ResponseBody
    public String setWonderful(int id){
        discussPostService.updateStatus(id,1);

        //将贴子同步到ElasticSearch中
        //触发发帖事件
        Event event = new Event()
                .setTopic(TOPIC_PUBLISH)
                .setUserId(hostHolder.getUser().getId())//触发者
                .setEntityType(ENTITY_TYPE_POST)
                .setEntityId(id);

        eventProducer.fireEvent(event);

        return JustDoItUtil.getJsonString(0);//0表示成功
    }


    /**
     *  删除
     * @param id
     * @return
     */
    @PostMapping("/delete")
    @ResponseBody
    public String setDelete(int id){
        discussPostService.updateStatus(id,2);

        //将贴子同步到ElasticSearch中
        //触发删帖事件
        Event event = new Event()
                .setTopic(TOPIC_DELETE)
                .setUserId(hostHolder.getUser().getId())//触发者
                .setEntityType(ENTITY_TYPE_POST)
                .setEntityId(id);

        eventProducer.fireEvent(event);

        return JustDoItUtil.getJsonString(0);//0表示成功
    }
````



### 1.5 页面--ajax

设置一个隐藏框，用于方便获取postId

```html
<div class="float-right">
						<input type="hidden" id="postId" th:value="${post.id}">
						<button type="button" class="btn btn-danger btn-sm" id="topBtn"
								th:disabled="${post.type== 1}">置顶</button>
						<button type="button" class="btn btn-danger btn-sm" id="wonderfulBtn"
								th:disabled="${post.status == 1}">加精</button>
						<button type="button" class="btn btn-danger btn-sm" id="deleteBtn"
								th:disabled="${post.status == 2}">删除</button>
</div>
```



js:

```js
$(function () {
    $("#topBtn").click(setTop);
    $("#wonderfulBtn").click(setWonderful);
    $("#deleteBtn").click(setDelete);
});


//置顶
function setTop() {
    var id = $("#postId").val();
    $.post({
        url: "/discuss/top",
        data: {"id":id},
        success:function (data) {
             data = $.parseJSON(data);
            if (data.code == 0){
                //置顶成功后,将隐藏置顶按钮
                $("#topBtn").attr("disabled","disabled");
            }else {
                alert(data.msg);
            }
        }
    })
}

//加精
function setWonderful() {
    var id = $("#postId").val();
    $.post({
        url: "/discuss/wonderful",
        data: {"id":id},
        success:function (data) {
            data = $.parseJSON(data);
            if (data.code == 0){
                //加精成功后,将隐藏置顶按钮
                $("#wonderfulBtn").attr("disabled","disabled");
            }else {
                alert(data.msg);
            }
        }
    });
}

//删除
function setDelete() {
    var id = $("#postId").val();
    $.post({
        url: "/discuss/delete",
        data: {"id":id},
        success:function (data) {
            data = $.parseJSON(data);
            if (data.code == 0){
                //删除成功后，跳转到主页
                location.href = "/index";
            }else {
                alert(data.msg);
            }
        }
    });
}
```



## 2. 权限管理

**SecurityConfig**

```java
/**
     * 授权
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(
                        "/user/setting",
                        "/user/upload",
                        "/discuss/add",
                        "/comment/add/**",
                        "/letter/**",
                        "/notice/**",
                        "like",
                        "/follow",
                        "/unfollow"
                )
                .hasAnyAuthority(
                        AUTHORITY_USER,
                        AUTHORITY_ADMIN,
                        AUTHORITY__MODERATOR
                )
                .antMatchers(
                        "/discuss/top",
                        "/discuss/wonderful"
                )
                .hasAnyAuthority(
                        AUTHORITY__MODERATOR//版主
                )
                .antMatchers(
                        "/discuss/delete"
                )
                .hasAnyAuthority(
                        AUTHORITY_ADMIN//管理员
                )
                .anyRequest().permitAll()//除了以上的请求需要权限,其它的不用
                .and().csrf().disable();//禁用csrf,由于该项目的ajax请求过多,不想改,故禁用csrf
```



## 3.按钮显示

**1.导入SpringSecurity的命名空间**

```html
<html xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
```

**2.页面配置访问权限 sec:authorize**

```html
<div class="float-right">
						<input type="hidden" id="postId" th:value="${post.id}">
						<button type="button" class="btn btn-danger btn-sm" id="topBtn"
								th:disabled="${post.type== 1}" sec:authorize="hasAnyAuthority('moderator')">置顶</button>
						<button type="button" class="btn btn-danger btn-sm" id="wonderfulBtn"
								th:disabled="${post.status == 1}" sec:authorize="hasAnyAuthority('moderator')">加精</button>
						<button type="button" class="btn btn-danger btn-sm" id="deleteBtn"
								th:disabled="${post.status == 2}" sec:authorize="hasAnyAuthority('admin')">删除</button>
</div>
```





# 五、Redis 高级数据类型

![image-20200910184309504](imgaes/image-20200910184309504.png)





## 1.HyperLogLog

```java
 //HyperLogLog
    //统计20玩个重复数据的独立总数
    @Test
    public void testHyperLogLOg(){
       String redisKey = "test:hll:01";

        for (int i = 1; i < 100000; i++) {
            redisTemplate.opsForHyperLogLog().add(redisKey,i);
        }
        for (int i = 1; i < 100000; i++) {
            int r = (int) (Math.random() * 100000 + 1); // 1---10万
            redisTemplate.opsForHyperLogLog().add(redisKey,r);
        }
        Long size = redisTemplate.opsForHyperLogLog().size(redisKey);
        System.out.println(size);
    }

    //将3组数据合并,再统计合并后的重复数据的独立总数
    @Test
    public void HyperLogLogUnion(){
       String redisKey2 = "test:hll:02";
        for (int i = 1; i < 10000; i++) {
            redisTemplate.opsForHyperLogLog().add(redisKey2,i);
        }
        String redisKey3 = "test:hll:03";
        for (int i = 5001; i < 15000; i++) {
            redisTemplate.opsForHyperLogLog().add(redisKey3,i);
        }
        String redisKey4 = "test:hll:04";
        for (int i = 10001; i < 20000; i++) {
            redisTemplate.opsForHyperLogLog().add(redisKey4,i);
        }

        String unionKey = "test:hll:union";
        redisTemplate.opsForHyperLogLog().union(unionKey,redisKey2,redisKey3,redisKey4);

        Long size = redisTemplate.opsForHyperLogLog().size(unionKey);
        System.out.println(size);
    }

```



## 2.BitMap

```java
 //BitMap
    //统计一组数据的布尔值
    @Test
    public void testBitMap(){
       String redisKey = "test:bm:01";

       //记录  没有设置就是false  l: 下标位置
        redisTemplate.opsForValue().setBit(redisKey,1,true);
        redisTemplate.opsForValue().setBit(redisKey,4,true);
        redisTemplate.opsForValue().setBit(redisKey,7,true);

        //查询
        System.out.println(redisTemplate.opsForValue().getBit(redisKey,0));//false
        System.out.println(redisTemplate.opsForValue().getBit(redisKey,1));//true
        System.out.println(redisTemplate.opsForValue().getBit(redisKey,2));//false

        //统计
        Object obj = redisTemplate.execute(new RedisCallback() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {

                return connection.bitCount(redisKey.getBytes());
            }
        });
        System.out.println(obj);
    }

    //统计三组数据的布尔值,并对3组数据做OR运算
    @Test
    public void testBitMapOperation(){
       String redisKey2 = "test:bm:02";
       redisTemplate.opsForValue().setBit(redisKey2,0,true);
        redisTemplate.opsForValue().setBit(redisKey2,1,true);
        redisTemplate.opsForValue().setBit(redisKey2,2,true);

        String redisKey3 = "test:bm:03";
        redisTemplate.opsForValue().setBit(redisKey3,2,true);
        redisTemplate.opsForValue().setBit(redisKey3,3,true);
        redisTemplate.opsForValue().setBit(redisKey3,4,true);

        String redisKey4 = "test:bm:04";
        redisTemplate.opsForValue().setBit(redisKey4,4,true);
        redisTemplate.opsForValue().setBit(redisKey4,5,true);
        redisTemplate.opsForValue().setBit(redisKey4,6,true);

        String redisKey = "test:bm:or";
        Object obj = redisTemplate.execute(new RedisCallback() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                connection.bitOp(RedisStringCommands.BitOperation.OR,
                        redisKey.getBytes(),redisKey2.getBytes(),redisKey3.getBytes(),redisKey4.getBytes());
                return connection.bitCount(redisKey.getBytes());
            }
        });
        System.out.println(obj);

        for (int i = 0; i < 6; i++) {
            System.out.println(redisTemplate.opsForValue().getBit(redisKey,i));
        }

    }
```



# 六、网站数据统计

![image-20200911195554623](imgaes/image-20200911195554623.png)

## 1.RedisKeyUtil

```java
public class RedisKeyUtil {
    
    
    //网站统计
    private static final  String PREFIX_UV = "uv";//独立访客
    private static final String PREFIX_DAU = "dau";//日活跃用户
    
    
    //单日UV 独立访客
    public static String getUVKey(String date){
        return PREFIX_UV + SPLIT + date;
    }

    //区间UV
    public static String getUVKey(String startDate,String endDate){
        return PREFIX_UV + SPLIT + startDate + SPLIT + endDate;
    }

    //单日活跃用户
    public static String getDAUKey(String date){
        return PREFIX_DAU + SPLIT + date;
    }

    //区间活跃用户
    public static String getDAUKey(String startDate,String endDate){
        return  PREFIX_DAU + SPLIT + startDate + SPLIT + endDate;
    }
    
}
```



## 2.DataService

```java
package com.justodit.service;

import com.justodit.util.RedisKeyUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.RedisStringCommands;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

/**
 * 数据统计 站点数据同居
 * @author liuxu
 */
@Service
public class DataService {


    @Autowired
    private RedisTemplate redisTemplate;

    private SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");

    /**
     * //将指定的ip计入UV  HyperLogLOg
     * @param ip
     */
    public void recordUV(String ip){
        String redisKey  = RedisKeyUtil.getUVKey(df.format(new Date()));
        redisTemplate.opsForHyperLogLog().add(redisKey,ip);

    }

    /**
     *  //统计指定日志范围内的UV   HyperLogLOg
     * @param start
     * @param end
     * @return
     */
    public long calculateUV(Date start,Date end){
        if (start == null || end == null){
            throw new IllegalArgumentException("参数不能为空");
        }
        //整理该日期范围内的key
        List<String> keyList = new ArrayList<>();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(start);
        while (!calendar.getTime().after(end)){//时间不晚于end的时间
            String key = RedisKeyUtil.getUVKey(df.format(calendar.getTime()));
            keyList.add(key);
            calendar.add(Calendar.DATE,1);//加一天;
        }
        //合并数据
        String redisKey = RedisKeyUtil.getUVKey(df.format(start),df.format(end));
        redisTemplate.opsForHyperLogLog().union(redisKey,keyList.toArray());

        //返回统计结果
        return redisTemplate.opsForHyperLogLog().size((redisKey));

    }

    /**
     *  //将指定用户计入DAU  日活跃用户 以userId为索引,存布尔值
     * @param userId
     */
    public void recordDAU(int userId){
        String redisKey = RedisKeyUtil.getDAUKey(df.format(new Date()));
        redisTemplate.opsForValue().setBit(redisKey,userId,true);
    }

    /**
     * //统计指定日期范围内的DAU  只要当天访问了网站就算活跃用户  
     * @param start
     * @param end
     * @return
     */
    public long calculateDAU(Date start,Date end){
        if (start == null || end == null){
            throw new IllegalArgumentException("参数不能为空");
        }
        //整理该日期范围内的key
        List<byte[]> keyList = new ArrayList<>();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(start);
        while (!calendar.getTime().after(end)){//时间不晚于end的时间
            String key = RedisKeyUtil.getDAUKey(df.format(calendar.getTime()));
            keyList.add(key.getBytes());
            calendar.add(Calendar.DATE,1);//加一天;
        }

        //进行or运算
        return (long)redisTemplate.execute(new RedisCallback() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                String redisKey = RedisKeyUtil.getDAUKey(df.format(start),df.format(end));//将起始结束时间作为key
                connection.bitOp(RedisStringCommands.BitOperation.OR,redisKey.getBytes(),keyList.toArray(new byte[0][0]));
                return connection.bitCount(redisKey.getBytes());//返回结果
            }
        });
    }
}

```



## 3.DataInterceptor

用户登陆的时候进行记录

```java
package com.justodit.interceptor;

import com.justodit.entity.User;
import com.justodit.service.DataService;
import com.justodit.util.HostHolder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class DataInterceptor implements HandlerInterceptor {

    @Autowired
    private DataService dataService;

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //统计UV  独立访客
        String ip = request.getRemoteHost();
        dataService.recordUV(ip);

        //统计DAU 日活跃用户
        User user = hostHolder.getUser();
        if (user != null){
            dataService.recordDAU(user.getId());
        }
        return true;
    }



}

```



## 4.Controlelr

```java
package com.justodit.controller;
/**
 * 网站统计  UV独立访客   DAU日活跃用户
 * @author  liuxu
 */

import com.justodit.service.DataService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import java.util.Date;

@Controller
public class DataController {

    @Autowired
    private DataService dataService;

    //跳转统计页面
    @RequestMapping(value = "/data",method = {RequestMethod.GET,RequestMethod.POST})
    public String getDataPage(){
        return "/site/admin/data";
    }

    //统计网站UV
    @RequestMapping(value = "/data/uv",method = RequestMethod.POST)
    public String getUV(@DateTimeFormat(pattern = "yyyy-MM-dd") Date start,
                        @DateTimeFormat(pattern = "yyyy-MM-dd")Date end, Model model){
        long uv = dataService.calculateUV(start,end);
        model.addAttribute("uvResult",uv);
        model.addAttribute("uvStartDate",start);
        model.addAttribute("uvEndDate",end);
        return "forward:/data";
    }

    //统计活跃用户 DAU
    @RequestMapping(value = "/data/dau",method = RequestMethod.POST)
    public String getDAU(@DateTimeFormat(pattern = "yyyy-MM-dd") Date start,
                         @DateTimeFormat(pattern = "yyyy-MM-dd")Date end, Model model){
        long dau = dataService.calculateDAU(start,end);
        model.addAttribute("dauResult",dau);
        model.addAttribute("dauStartDate",start);
        model.addAttribute("dauEndDate",end);
        return "forward:/data";
    }
}

```



## 5. SecutiryConfig

在SpringSecurity中设置只有管理员才能访问此功能

![image-20200911212045362](imgaes/image-20200911212045362.png)



## 6.页面

```html
		<!-- 内容 -->
		<div class="main">
			<!-- 网站UV -->
			<div class="container pl-5 pr-5 pt-3 pb-3 mt-3">
				<h6 class="mt-3"><b class="square"></b> 网站 UV</h6>
				<form class="form-inline mt-3" method="post" th:action="@{/data/uv}">
					<input type="date" class="form-control" required name="start" th:value="${#dates.format(uvStartDate,'yyyy-MM-dd')}"/>
					<input type="date" class="form-control ml-3" required name="end" th:value="${#dates.format(uvEndDate,'yyyy-MM-dd')}"/>
					<button type="submit" class="btn btn-primary ml-3">开始统计</button>
				</form>
				<ul class="list-group mt-3 mb-3">
					<li class="list-group-item d-flex justify-content-between align-items-center">
						统计结果
						<span class="badge badge-primary badge-danger font-size-14" th:text="${uvResult}">0</span>
					</li>
				</ul>
			</div>
			<!-- 活跃用户 -->
			<div class="container pl-5 pr-5 pt-3 pb-3 mt-4">
				<h6 class="mt-3"><b class="square"></b> 活跃用户</h6>
				<form class="form-inline mt-3" method="post" th:action="@{/data/dau}">
					<input type="date" class="form-control" required name="start" th:value="${#dates.format(dauStartDate,'yyyy-MM-dd')}"/>
					<input type="date" class="form-control ml-3" required name="end" th:value="${#dates.format(dauEndtDate,'yyyy-MM-dd')}"/>
					<button type="submit" class="btn btn-primary ml-3">开始统计</button>
				</form>
				<ul class="list-group mt-3 mb-3">
					<li class="list-group-item d-flex justify-content-between align-items-center">
						统计结果
						<span class="badge badge-primary badge-danger font-size-14" th:text="${dauResult}">0</span>
					</li>
				</ul>
			</div>				
		</div>
```



# 七、任务执行何调度

![image-20200912154721418](imgaes/image-20200912154721418.png)



## 1. JDK线程池

ExecutorService 普通线程池

ScheduledExecutorService 定时任务线程池

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class ThreadPoolTest {

    @Autowired
    private TestService testService;

    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolTest.class);

    //JDK普通线程池
    private ExecutorService executorService = Executors.newFixedThreadPool(5);//5个线程

    //JDK可执行定时任务的线程池
    private ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);
    
    
    //阻塞
    private void sleep(long m){
        try {
            Thread.sleep(m);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //1.JDK普通线程池
    @Test
    public void testExecutorService(){
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("hello ExecutorService");
            }
        };

        for (int i = 0; i < 10; i++) {
            executorService.submit(task);
        }

        sleep(10000);
    }

    //2.JDK定时任务线程池
    @Test
    public void testScheduleExecutorService(){
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("hello ScheduleExecutorService");
            }
        };

        scheduledExecutorService.scheduleAtFixedRate(task,10000,1000, TimeUnit.MILLISECONDS);//调用一次可一直执行

        sleep(30000);//执行时间30秒
    }

```





## 2. Spring线程池

ThreadPooTasklExecutor 普通线程池

 ThreadPoolTadkScheduler  定时任务线程池



配置

```properties
#TastExcutionProperties  普通线程池
        #核心线程数量
spring.task.execution.pool.core-size=5
        # 最多扩容到15个
spring.task.execution.pool.max-size=15
        # 队列容量  等待队列 缓冲
spring.task.execution.pool.queue-capacity=100



# TaskScheduleProperties  定时任务线程池
spring.task.scheduling.pool.size=5
```





```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class ThreadPoolTest {


    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolTest.class);


    //Spring普通线程池
    @Autowired
    private ThreadPoolTaskExecutor taskExecutor;

    //Spring可定时任务的线程池
    @Autowired
    private ThreadPoolTaskScheduler taskScheduler;
    
    
    //阻塞
    private void sleep(long m){
        try {
            Thread.sleep(m);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    
    //3.Spring普通线程池  需要先启用@EnableScheduling
    @Test
    public void testThreadPoolTaskExecutor(){
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("hello ThreadPoolTaskExecutor");
            }
        };

        for (int i = 0; i < 10; i++) {
            taskExecutor.submit(task);
        }
        sleep(10);
    }

    //4.Spring定时任务线程池
    @Test
    public void testScheduledExecutorService(){
        Runnable task = new Runnable() {
            @Override
            public void run() {
                logger.debug("hello ThreadPoolTaskExecutor");
            }
        };
        Date startTime = new Date(System.currentTimeMillis() + 10000);
        taskScheduler.scheduleAtFixedRate(task,startTime,1000);

        sleep(30000);
    }

```



简化写法  @Async  @Scheduled

TestService

```java
@Service
public class TestService {

    private static final Logger logger = LoggerFactory.getLogger(TestService.class);

    //可以让该方法在多线程环境下,被异步调用
    @Async
    public void execute1(){
        logger.debug("execute1");
    }

    @Scheduled(initialDelay = 10000,fixedRate = 1000)
    public void execute2(){
        logger.debug("execute2");
    }
}
```



```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class ThreadPoolTest {

    @Autowired
    private TestService testService;
    
    
    //5.Spring普通线程池(简化@Async)
    @Test
    public void testThreadPoolTaskExecutorSimple(){
        for (int i = 0; i < 10; i++) {
            testService.execute1();
        }

        sleep(10000);
    }

    //6.Spring定时任务线程池(简化@Scheduled)
    @Test
    public void testThreadPoolTaskSchedulerSimple(){
        sleep(30000);
    }
```



## 3.quartz

核心类：Schedule,Job,Trigger

![image-20200912174143685](imgaes/image-20200912174143685.png)

**quartz要与数据库交互，所以要导入数据表**

![image-20200912172637197](imgaes/image-20200912172637197.png)

大致流程

1.通过Job接口，定义一个任务

2.通过JobDetail何Trigger接口配置Job



### 1. 配置

```properties
# QuartzProperties
spring.quartz.job-store-type=jdbc
spring.quartz.scheduler-name=justdoitScheduler
spring.quartz.properties.org.quartz.scheduler.instanceId=AUTO
spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX
spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
spring.quartz.properties.org.quartz.jobStore.isClustered=true
spring.quartz.properties.org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool
spring.quartz.properties.org.quartz.threadPool.threadCount=5
```



### 2.Job

任务

```
package com.justodit.quartz;

import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

public class AlphaJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        System.out.println(Thread.currentThread().getName() + ":execute a quartz job");

    }
}
```



### 3.Config

配置类执行一次就行将@Bean注释，会将任务等存到数据库，再次启动项目访问数据库，会读取数据库中的任务，触发器等等。

```java
package com.justodit.config;

import com.justodit.quartz.AlphaJob;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.quartz.JobDetailFactoryBean;
import org.springframework.scheduling.quartz.SimpleTriggerFactoryBean;

//配置  ->  数据库  -> 调用(这个配置类quartz值使用1次,执行一次后,注释@Bean)
@Configuration
public class QuartzConfig {

    //FactoryBean可简化Bean的实例化过程:
    //1.通过FactoryBean分装了Bean的实例化过程
    //2.将FactoryBean装配到Spring容器里
    //3.将FactoryBean注入给其它的Bean
    //4该Bean得到的是FactoryBean所管理的对象实例


    //配置JobDetail
    //@Bean
    public JobDetailFactoryBean alphaJobDetail(){
        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
        factoryBean.setJobClass(AlphaJob.class);
        factoryBean.setName("alphaJob");
        factoryBean.setGroup("alphaJobGroup");
        factoryBean.setDurability(true);//持久保存
        factoryBean.setRequestsRecovery(true);//该任务是不是可恢复
        return factoryBean;
    }

    //配置Trigger(SimpleTriggerFactoryBean,CornTriggerFactoryBean)
   // @Bean
    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail){
        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
        factoryBean.setJobDetail(alphaJobDetail);
        factoryBean.setName("alphaTrigger");
        factoryBean.setGroup("alphaTriggerGroup");
        factoryBean.setRepeatInterval(3000);//多久执行一次任务
        factoryBean.setJobDataMap(new JobDataMap());//Job状态
        return factoryBean;
    }

}

```





删除Job

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class QuartzTest {

    @Autowired
    private Scheduler scheduler;


    //删除数据库中的job
    @Test
    public void testDeleteJob(){
        try {
           boolean result =  scheduler.deleteJob(new JobKey("alphaJob","alphaJobGroup"));
            System.out.println(result);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }
}

```





# 八、贴子热度排行--quartz

![image-20200914212411592](imgaes/image-20200914212411592.png)

先将贴子存放到redis中，通过定时任务，没间隔5分钟从redis中获取要score更新的key，在进行计算贴子的分数，更新贴子分数

触发将贴子存放到redis中的情况：新增贴子、点赞、加精、添加评论



## 0.RedisKeyUtil

```java
    //quartz定时获取贴子的热度排行
    private static final String PREFIX_POST = "post";

 	//统计贴子分数key
    public static String getPostScoreKey(){
        return PREFIX_POST + SPLIT + "score";
    }
```



## 1.新增、点赞、加精、添加评论

新增、加精

```java
@Controller
@RequestMapping("/discuss")
public class DiscussPostController implements Constant {
    
    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private UserService userService;

    @Autowired
    private CommentService commentService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private RedisTemplate redisTemplate;
    
    
 /**
     * 发布帖子
     * @param title 标题
     * @param content  内容
     * @return
     */
    @PostMapping("/add")
    @ResponseBody
    public String addDiscussPost(String title,String content){
       
        .........

        DiscussPost discussPost = new DiscussPost();
       ............


        //计算贴子的分数  先将贴子存放到redis中 在进行计算
        String redisKey = RedisKeyUtil.getPostScoreKey();
        redisTemplate.opsForSet().add(redisKey,discussPost.getId());



        //报错的情况,将来用以处理
        return JustDoItUtil.getJsonString(0,"发布成功");
    }
    
    
    /**
     *  加精
     * @param id
     * @return
     */
    @PostMapping("/wonderful")
    @ResponseBody
    public String setWonderful(int id){
        discussPostService.updateStatus(id,1);

        //将贴子同步到ElasticSearch中
        //触发发帖事件
        Event event = new Event()
                .setTopic(TOPIC_PUBLISH)
                .setUserId(hostHolder.getUser().getId())//触发者
                .setEntityType(ENTITY_TYPE_POST)
                .setEntityId(id);

        eventProducer.fireEvent(event);


        //将贴子存放到redis中,计算帖子的分数  热帖排行
        String redisKey = RedisKeyUtil.getPostScoreKey();
        redisTemplate.opsForSet().add(redisKey,id);

        return JustDoItUtil.getJsonString(0);//0表示成功
    }


```

点赞

```java
@Controller
public class LikeController implements Constant {

    @Autowired
    private LikeService likeService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private RedisTemplate redisTemplate;
    
    
    /**
     * 点赞
     * @param entityType
     * @param entityId
     * @param entityUserId
     * @param postId
     * @return
     */
    @RequestMapping(value = "/like",method = RequestMethod.POST)
    @ResponseBody
    public String like(int entityType,int entityId,int entityUserId,int postId){
        User user = hostHolder.getUser();

      .....................

        //对贴子点赞
        if (entityType == ENTITY_TYPE_POST){
            //将贴子存放到redis中,计算帖子的分数  热帖排行
            String redisKey = RedisKeyUtil.getPostScoreKey();
            redisTemplate.opsForSet().add(redisKey,postId);
        }

        return JustDoItUtil.getJsonString(0,null,map);
    }

```



添加评论

```java
@Controller
@RequestMapping("/comment")
public class CommentController implements Constant  {


    @Autowired
    private CommentService commentService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private EventProducer eventProducer;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private RedisTemplate redisTemplate;

      /**
     * 添加评论
     * @param discussPostId 贴子id
     * @param comment  评论
     * @return
     */
    @RequestMapping(value = "/add/{discussPostId}",method = RequestMethod.POST)
    public String addComment(@PathVariable("discussPostId")int discussPostId, Comment comment){

       
		.........................

            //将贴子存放到redis中,计算帖子的分数  热帖排行
            String redisKey = RedisKeyUtil.getPostScoreKey();
            redisTemplate.opsForSet().add(redisKey,discussPostId);



    

}
```



## 2.PostScoreRefreshJob



```xml
<!-- 修改贴子状态 0-正常; 1-精华; 2-拉黑;   -->
<update id="updateScore">
    update discuss_post set score = #{score} where id = #{id}
</update>
```

```java
package com.justodit.quartz;

import com.justodit.entity.DiscussPost;
import com.justodit.service.DiscussPostService;
import com.justodit.service.ElasticSearchService;
import com.justodit.service.LikeService;
import com.justodit.util.Constant;
import com.justodit.util.RedisKeyUtil;
import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.BoundSetOperations;
import org.springframework.data.redis.core.RedisTemplate;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class PostScoreRefreshJob implements Job, Constant {


    private static final Logger logger = LoggerFactory.getLogger(PostScoreRefreshJob.class);

    //纪元
    private static final Date epoch;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private LikeService likeService;

    @Autowired
    private ElasticSearchService elasticSearchService;


    //初始化纪元
    static{
        try {
            epoch = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2014-08-01 00:00:00");
        } catch (ParseException e) {
            throw new RuntimeException("初始化纪元失败"+e);
        }
    }


    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        String redisKey = RedisKeyUtil.getPostScoreKey();
        BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);
        if (operations.size() == 0){
            logger.info("任务取消,没有需要刷新的贴子");
            return;
        }

        logger.info("[任务开始,正在刷新贴子分数]:"+operations.size());

        while (operations.size() > 0){
            //刷新
            this.refresh((Integer)operations.pop());
        }
        logger.info("[任务结束,贴子分数刷新完毕]");
    }

    //刷新方法，计算权重，更新数据库中score
    private void  refresh(int postId){
        DiscussPost post = discussPostService.findDiscussPostById(postId);

        if (post == null){
            logger.error("该帖子不存在: id = "+post.getId());
            return;
        }

        //是否加精
        boolean wonderful = post.getStatus() == 1;
        //评论数量
        int commentCount = post.getCommentCount();
        //点赞数量
        long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST,postId);

        //计算权重
        double w = (wonderful ? 75 : 0) + commentCount * 10 + likeCount * 2;
        //分数  =  贴子权重   + 距离天数
        double score = Math.log10(Math.max(w,1))
                + (post.getCreateTime().getTime() - epoch.getTime()) / (1000 * 3600 * 24);
        //跟新贴子的分数
        discussPostService.updateScore(postId,score);
        //同步搜索数据  ElasticSearch
        post.setScore(score);
        elasticSearchService.saveDiscussPost(post);
    }
}

```



## 2.QuartzConfig

```java
@Configuration
public class QuartzConfig {
    
    //配置JobDetail  刷新贴子分数任务
    @Bean
    public JobDetailFactoryBean postScoreRefreshJobDetail(){
        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();
        factoryBean.setJobClass(PostScoreRefreshJob.class);
        factoryBean.setName("postScoreRefreshJob");
        factoryBean.setGroup("justdoitJobGroup");
        factoryBean.setDurability(true);//持久保存
        factoryBean.setRequestsRecovery(true);//该任务是不是可恢复
        return factoryBean;
    }

    //配置Trigger(SimpleTriggerFactoryBean,CornTriggerFactoryBean)
    @Bean
    public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail){
        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();
        factoryBean.setJobDetail(postScoreRefreshJobDetail);
        factoryBean.setName("postScoreRefreshTrigger");
        factoryBean.setGroup("justdoitTriggerGroup");
        factoryBean.setRepeatInterval(1000 * 60 * 5);//多久执行一次任务 5分钟
        factoryBean.setJobDataMap(new JobDataMap());//Job状态
        return factoryBean;
    }

}
```



## 3.重构DiscussPostMapper

重构DiscussPostMapper中的selectDiscussPosts方法

![image-20200914211555106](imgaes/image-20200914211555106.png)

当点击的最新、最热的时候需要在路径上拼接scoreMode   0代表最新  1 代表最热

![image-20200914211723115](imgaes/image-20200914211723115.png)

![image-20200914211743178](imgaes/image-20200914211743178.png)

```xml
    <!--   查询帖子    status为2表示帖子被拉黑  orderMode为最新  orderMode为最热-->
    <select id="selectDiscussPosts" resultType="com.justodit.entity.DiscussPost">
        select <include refid="selectFields"></include>
        from discuss_post
        where status != 2
        <if test="userId!=0">
            and user_id = #{userId}
        </if>
        <if test="orderMode==0">
            order by `type` desc  ,create_time desc
        </if>
        <if test="orderMode==1">
            order by `type` desc  ,score desc ,create_time desc
        </if>
        limit #{offset},#{limit}
    </select>
```

![image-20200914212116963](imgaes/image-20200914212116963.png)



![image-20200914212203087](imgaes/image-20200914212203087.png)



## 4.页面

![image-20200914212247044](imgaes/image-20200914212247044.png)





# 十一、优化网站性能--缓存

![image-20200914212452375](imgaes/image-20200914212452375.png)

![image-20200914213409319](imgaes/image-20200914213409319.png)

![image-20200914213528460](imgaes/image-20200914213528460.png)


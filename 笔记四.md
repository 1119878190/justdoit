# 一.Redis



## 1.基础

- **Redis是一款基于键值对的NoSql数据库，它的值支持多种数据结构：字符串String，哈希hashes，列表list，集合set，有序集合zset**

- **Redis将所有的数据都存放到内存中，所以他的读写性能十分惊人。同时，Redis还可以将内存中的数据一快照或日志保存到硬盘上，以保证数据的安全性。**

- **Redis典型的应用场景包括：缓存，排行榜，计数器，社交网络，消息队列等。**



在命令行中的命令

**String:**

| 命令                                           | 解释                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| get key                                        | 获取key的值                                                  |
| set key v                                      | 设置key的值                                                  |
| del key                                        | 删除key（应用于所有类型）                                    |
| incr key                                       | 将储存的值加上1                                              |
| decr key                                       | 将储存的值减去1                                              |
| incrby key amout                               | 加上整数amount                                               |
| decrby key amout                               | 减去整数amount                                               |
| incrbybyfloat key amout                        | 加上浮点数amount字符串二进制                                 |
| append key v                                   | 将值追加到key当前储存值的末尾                                |
| getrange key start end                         | 获取下标start到end的字符串                                   |
| setrange key offset v                          | 将字符串看做二进制位串，并将位串中偏移量为offset的二进制位的值 |
| getbit key offset                              | 将字符串看做是二进制位串值为1的二进制位的数量，如果给定了可选的start偏移量和end偏移量，那么只对偏移量指定范围的二进制位进行统计 |
| bitop operation dest-key key-name [key-name …] | 对一个或多个二进制位串进行 并and，或 or，异或XOR，非NOT 在内的任意一种安位运算符操作（bitwise operation），并将计算的结果放到dest -key里面 |



**Hash:**

| 命令                            | 解释                           |
| ------------------------------- | ------------------------------ |
| hset key field value            | 存放                           |
| hget key field                  | 获取值                         |
| hmget hkey key…                 | 获取多个值                     |
| hmset hkey key v…               | 为多个key设置值                |
| hdel hkey key…                  | 删除多个值并返回               |
| hlen hkey                       | 返回总数量                     |
| hexists hkey key                | 检查key是否存在在散列中        |
| hkeys hkey                      | 获取散列中所有key              |
| hvals hkey                      | 获取三列中所有值               |
| hgetall hkey                    | 获取散列                       |
| hincrby hkey key increment      | 为key的值上加上整数increment   |
| hincrbyfloat hkey key increment | 为key的值上加上浮点数increment |



**List:**

| 命令                 | 解释                                     |
| -------------------- | ---------------------------------------- |
| rpush key [v…]       | 将一个或多个加入列表右端                 |
| lpush key [v…]       | 将一个或多个加入列表左端                 |
| rpop key             | 移除并返回最右端的元素                   |
| lpop key             | 移除并返回列表最左端的元素               |
| lindex key size      | 返回下标（偏移量）为size的元素           |
| lrange key start end | 返回从start 到end的元素 包含start和end   |
| ltrim key start end  | 只保留从start 到end的元素 包含start和end |



**Set:**

| 令                                 | 解释                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| sadd key item …                    | 添加多个，返回新添加的个数（已存在的不算）                   |
| srem key item…                     | 从集合移除多个元素 ，返回被移除元素的数量                    |
| sismember key item                 | 检查元素item是否在集合中                                     |
| scard key                          | 返回集合总数                                                 |
| smembers key                       | 返回所有元素                                                 |
| srandmember key cout               | 随机返回cout个元素 cout为正整数 随机元素不重复 相反可能会出现重复 |
| spop key                           | 随机的移除一个元素 并返回已删除的元素                        |
| smove key1 key2 item               | 如果key1中包含item 移除key1中的item 添加到key2中，成功返回1 失败返回0 |
| 差运算 sdiffstore newkey key key1… | 将存在于key集合但是不存在key1…集合的其他元素 放到newkey里面（咬掉一口剩下的） |
| 交运算 sinter key…                 | 返回所有集合的交集（返回我们都有的的）                       |
| 交运算 sinterstore newkey key…     | 返回多个集合的交集生成集合newkey                             |
| 并运算 sunion key…                 | （返回我们不重复的所有元素 ）                                |
| 并运算 sunion newkey key…          | 结果放到newkey中                                             |



**ZSet:**

| 命令                         | 解释                            |
| ---------------------------- | ------------------------------- |
| zadd key score member …      | 添加多个                        |
| zerm key memer…              | 移除多个                        |
| zcard key                    | 返回所有成员                    |
| zincrby key incremnet member | 将member成员的分值加上increment |
| zcount key min max           | 返回分值在 min和max中间的排名   |
| zrank key member             | 返回成员member在集合中的排名    |
| zscore key member            | 返回member的分值                |
| zrange key start stop        | 返回 介于两者之间的成员         |



**全局命令**

| 命令                              | 解释                               |
| --------------------------------- | ---------------------------------- |
| keys *                            | 查看所有的key                      |
| type key                          | 查看类型                           |
| exists key                        | 是否存在key                        |
| del key                           | 删除key                            |
| expire key  time (expire user 10) | 设置存活时间（use 存活时间为10秒） |



## 2.SpringBoot整合Redis



### 2.1 引入依赖

``` xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>2.3.3.RELEASE</version>
</dependency>

```



### 2.2 配置redis

​		--编写数据库参数

``` properties
#Redis配置
spring.redis.database=1
spring.redis.host=localhost
spring.redis.port=6379

```

​		--编写配置类，构造RedisTemplate



``` java
package com.justodit.config;
//配置Redis序列化
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.RedisSerializer;


@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory factory){
        RedisTemplate<String ,Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        //指定序列化方式
        //设置key的序列化方式
        template.setKeySerializer(RedisSerializer.string());

        //设置value的序列化方法
        template.setValueSerializer(RedisSerializer.json());

        //设置hash的key的序列化方式
        template.setHashKeySerializer(RedisSerializer.string());

        //设置hash的value的序列化方式
        template.setHashValueSerializer(RedisSerializer.json());

        //让配置生效
        template.afterPropertiesSet();
        return template;

    }
}

```



### 2.3访问redis

``` java
package com.justodit;


import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.core.BoundValueOperations;
import org.springframework.data.redis.core.RedisOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.SessionCallback;
import org.springframework.test.context.junit4.SpringRunner;


import java.util.concurrent.TimeUnit;

@RunWith(SpringRunner.class)
@SpringBootTest
public class RedisTest {

   @Autowired
    private RedisTemplate<String,Object> redisTemplate;

   //String
   @Test
    public void testString(){
       String redisKey = "test:count";
       redisTemplate.opsForValue().set(redisKey,1);

       System.out.println(redisTemplate.opsForValue().get(redisKey));
       System.out.println(redisTemplate.opsForValue().increment(redisKey));
       System.out.println(redisTemplate.opsForValue().decrement(redisKey));

   }


   //Hash
   @Test
    public void testHash(){
       String redisKey = "test:user";
       redisTemplate.opsForHash().put(redisKey,"id",1);
       redisTemplate.opsForHash().put(redisKey,"username","zhangsan");

       System.out.println(redisTemplate.opsForHash().get(redisKey,"id"));
       System.out.println(redisTemplate.opsForHash().get(redisKey,"username"));

   }

   //List
   @Test
    public void testList(){
       String redisKey = "test:ids";

       redisTemplate.opsForList().leftPush(redisKey,101);
       redisTemplate.opsForList().leftPush(redisKey,101);
       redisTemplate.opsForList().leftPush(redisKey,102);
       redisTemplate.opsForList().leftPush(redisKey,103);
       redisTemplate.opsForList().leftPush(redisKey,104);

       System.out.println(redisTemplate.opsForList().size(redisKey));
       System.out.println(redisTemplate.opsForList().index(redisKey,0));
       System.out.println(redisTemplate.opsForList().range(redisKey,0,-1));

       System.out.println(redisTemplate.opsForList().leftPop(redisKey));
       System.out.println(redisTemplate.opsForList().leftPop(redisKey));
       System.out.println(redisTemplate.opsForList().leftPop(redisKey));
       System.out.println(redisTemplate.opsForList().leftPop(redisKey));
   }

   //Set
    @Test
    public void testSet(){
       String redisKey = "test:teachers";
       redisTemplate.opsForSet().add(redisKey,"刘备","张飞","关羽");

        System.out.println(redisTemplate.opsForSet().size(redisKey));
        System.out.println(redisTemplate.opsForSet().pop(redisKey));
        System.out.println(redisTemplate.opsForSet().members(redisKey));

    }

    //ZSet
    @Test
    public void testSortedSets(){
       String redisKey = "test:students";
       redisTemplate.opsForZSet().add(redisKey,"唐僧",80);
        redisTemplate.opsForZSet().add(redisKey,"孙悟空",70);
        redisTemplate.opsForZSet().add(redisKey,"沙僧",90);
        redisTemplate.opsForZSet().add(redisKey,"猪八戒",75);

        System.out.println(redisTemplate.opsForZSet().size(redisKey));
        System.out.println(redisTemplate.opsForZSet().score(redisKey,"猪八戒"));
        System.out.println(redisTemplate.opsForZSet().reverseRank(redisKey,"猪八戒"));
        System.out.println(redisTemplate.opsForZSet().reverseRange(redisKey,0,2));
    }

    @Test
    public void testKeys(){
        redisTemplate.delete("test:user");

        System.out.println(redisTemplate.hasKey("test:user"));
        redisTemplate.expire("test:students",10, TimeUnit.SECONDS);

    }

    //多次访问同一个key
    @Test
    public void testBoundOperation(){
       String redisKey = "test:count";
        BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);
        operations.increment();
        operations.increment();
        operations.increment();
        operations.increment();

        System.out.println(operations.get());
    }

    
}

```



### 2.4Redis编程式事务

``` java
//redis编程式事务
    @Test
    public void testTransactional(){
       Object obj = redisTemplate.execute(new SessionCallback() {

           @Override
           public  Object execute(RedisOperations operations) throws DataAccessException {
               String redisKey  = "test:tx";
               operations.multi();//开启事务

               operations.opsForSet().add(redisKey,"张三");
               operations.opsForSet().add(redisKey,"李四");
               operations.opsForSet().add(redisKey,"王五");
               System.out.println(operations.opsForSet().members(redisKey));

               return operations.exec();//执行
           }
       });

        System.out.println(obj);
    }
```





# 二、点赞--redis

## 1.点赞

​		**--支持对帖子，评论点赞。**

​		**--第一次点赞，第二次点赞**

### 1.1 Util 

用于设置redis的key

```java
package com.justodit.util;

public class RedisKeyUtil {

    private static final String SPLIT = ":";
    private static final String PREFIX_ENTITY_LIKE = "like:entity";

    //某个实体的赞
    //like:entity:entityType:entityId ---> set(userId)
    public static String getEntityLikeKey(int entityType,int entityId){
        return  PREFIX_ENTITY_LIKE +SPLIT + entityType  + SPLIT + entityId;
    }

}
```



### 1.2 Service



``` java
package com.justodit.service;

import com.justodit.util.RedisKeyUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

@Service
public class LikeService {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 点赞
     * @param userId 当前用户id
     * @param entityType  给点赞的类信息 1为帖子   2为评论和回复
     * @param entityId  实体id
     */
    public void like(int userId, int entityType,int entityId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        //判断当前用户是否点赞  查看是否有userId
        Boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);
        if (isMember){
            //已点赞
            redisTemplate.opsForSet().remove(entityLikeKey,userId);
        }else {
            //未点赞
            redisTemplate.opsForSet().add(entityLikeKey,userId);
        }

    }

    //查询实体点赞的数量
    public long findEntityLikeCount(int entityType,int entityId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        return redisTemplate.opsForSet().size(entityLikeKey);
    }

    //查询某人对某实体的点赞状态  有没有点过赞
    public int findEntityLikeStatus(int userId,int entityType,int entityId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        return redisTemplate.opsForSet().isMember(entityLikeKey,userId) ? 1:0;  //1点赞  0未点赞
    }
}

```



### 1.3 Controller



``` java
package com.justodit.controller;
//点赞
import com.justodit.entity.User;
import com.justodit.service.LikeService;
import com.justodit.util.HostHolder;
import com.justodit.util.JustDoItUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.HashMap;
import java.util.Map;

@Controller
public class LikeController {

    @Autowired
    private LikeService likeService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(value = "/like",method = RequestMethod.POST)
    @ResponseBody
    public String like(int entityType,int entityId){
        User user = hostHolder.getUser();

        //点赞
        likeService.like(user.getId(),entityType,entityId);
        //数量
        long likeCount = likeService.findEntityLikeCount(entityType,entityId);
        //状态
        int likeStatus = likeService.findEntityLikeStatus(user.getId(),entityType,entityId);

        Map<String,Object> map = new HashMap<>();
        map.put("likeCount",likeCount);
        map.put("likeStatus",likeStatus);

        return JustDoItUtil.getJsonString(0,null,map);
    }

}

```



页面

![image-20200901224323622](imgaes/image-20200901224323622.png)

![image-20200901224342374](imgaes/image-20200901224342374.png)

**discuss.js**

``` js
function like(btn,entityType,entityId) {

    $.post({
        url: "/like",
        data: {"entityType":entityType,"entityId":entityId},
        success:function (data) {
            data = $.parseJSON(data);
            if (data.code == 0){
                $(btn).children("i").text(data.likeCount);
                $(btn).children("b").text(data.likeStatus==1?'已赞':'赞');
            }else {
                alert(data.msg);
            }
        }
    })
}
```



## 2.首页点赞数量

​		**--统计帖子的点赞数量**

**HomeController**

![image-20200901223851669](imgaes/image-20200901223851669.png)

页面

![image-20200901223953065](imgaes/image-20200901223953065.png)

## 3.详情页点赞数量

​		**--统计点赞数量**

​		**--显示点赞状态**



**DiscussPostController**



``` java
  /**
     * 帖子详情   评论详情
     * @param discussPostId 帖子id
     * @param model
     * @return
     */
    @RequestMapping(value = "/detail/{discussPostId}",method = RequestMethod.GET)
    public String getDiscussPostById(@PathVariable("discussPostId")Integer discussPostId, Model model, Page page){

        //帖子
        DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
        model.addAttribute("post",post);

        //作者
        User user = userService.findUserById(post.getUserId());
        model.addAttribute("user",user);

        //查询多少赞
        long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST,discussPostId);
        model.addAttribute("likeCount",likeCount);

        //点赞状态
        int likeStatus = hostHolder.getUser() == null ? 0 :
                                likeService.findEntityLikeStatus(hostHolder.getUser().getId(),ENTITY_TYPE_POST,discussPostId);
        model.addAttribute("likeStatus",likeStatus);


        //评论分页信息
        page.setLimit(5);
        page.setPath("/discuss/detail/" + discussPostId);
        page.setRows(post.getCommentCount());

        //评论: 给帖子的评论
        //回复: 给评论的评论
        //评论的列表
        List<Comment> commentList = commentService.findCommentByEntity(
                                        ENTITY_TYPE_POST,post.getId(),page.getOffset(),page.getLimit());
        //评论的Vo列表 ViewObject
        List<Map<String,Object>> commentVoList = new ArrayList<>();
        if (commentList != null){
            for (Comment comment : commentList){
                //一个评论的VO  ViewObject
                Map<String,Object> commentVo = new HashMap<>();
                //评论
                commentVo.put("comment",comment);
                //评论的作者
                commentVo.put("user",userService.findUserById(comment.getUserId()));

                //查询多少赞
                likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT,comment.getId());
                commentVo.put("likeCount",likeCount);

                //点赞状态
                 likeStatus = hostHolder.getUser() == null ? 0 :
                        likeService.findEntityLikeStatus(hostHolder.getUser().getId(),ENTITY_TYPE_COMMENT,comment.getId());
                commentVo.put("likeStatus",likeStatus);

                //回复列表  不分页查询
                List<Comment> replyList = commentService.findCommentByEntity(
                                            ENTITY_TYPE_COMMENT,comment.getId(),0,Integer.MAX_VALUE);
                //回复的VO列表
                List<Map<String,Object>> replyVoList = new ArrayList<>();
                if (replyList != null){
                    for (Comment reply: replyList){
                        Map<String,Object> replyVo = new HashMap<>();
                        //回复
                        replyVo.put("reply",reply);
                        replyVo.put("user",userService.findUserById(reply.getUserId()));
                        // 回复的目标 targetId
                        User target = reply.getTargetId()==0 ? null: userService.findUserById(reply.getTargetId());
                        replyVo.put("target",target);

                        //查询多少赞
                        likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT,reply.getId());
                        replyVo.put("likeCount",likeCount);

                        //点赞状态
                        likeStatus = hostHolder.getUser() == null ? 0 :
                                likeService.findEntityLikeStatus(hostHolder.getUser().getId(),ENTITY_TYPE_COMMENT,reply.getId());
                        replyVo.put("likeStatus",likeStatus);

                        replyVoList.add(replyVo);
                    }
                }
                commentVo.put("replys",replyVoList);

                //回复数量
                int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT,comment.getId());
                commentVo.put("replyCount",replyCount);

                commentVoList.add(commentVo);
            }
        }

        model.addAttribute("comments",commentVoList);
        return "/site/discuss-detail";



    }
```



![image-20200901224207401](imgaes/image-20200901224207401.png)

![image-20200901224227005](imgaes/image-20200901224227005.png)

![image-20200901224239756](imgaes/image-20200901224239756.png)





# 三、我收到的赞

## 1.重构点赞功能

​		**--以用户为key，记录点赞数量**

​		**--increment(key),decrement(key)**



### 1.1 RedisKeyUtil

``` java
package com.justodit.util;

public class RedisKeyUtil {

    private static final String SPLIT = ":";
    private static final String PREFIX_ENTITY_LIKE = "like:entity";
    private static final String PREFIX_USER_LIKE  = "like:user";

    //某个实体的赞
    //like:entity:entityType:entityId ---> set(userId)
    public static String getEntityLikeKey(int entityType,int entityId){
        return  PREFIX_ENTITY_LIKE +SPLIT + entityType  + SPLIT + entityId;
    }

    //某个用户的赞
    //like:user:userId ----> int
    public static String getUserLikeKey(int userId){
        return PREFIX_USER_LIKE + SPLIT + userId;
    }

}

```



### 1.2 LikeService

``` java
@Service
public class LikeService {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 点赞  并增加,减少用户的点赞数量
     * @param userId 当前用户id
     * @param entityType  给点赞的类型 1为帖子   2为评论和回复
     * @param entityId  实体id
     * @param entityUserId 实体的作者id
     */
    public void like(int userId, int entityType,int entityId,int entityUserId){
       /* String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        //判断当前用户是否点赞  查看是否有userId
        Boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);
        if (isMember){
            //已点赞 取消
            redisTemplate.opsForSet().remove(entityLikeKey,userId);
        }else {
            //未点赞 点赞
            redisTemplate.opsForSet().add(entityLikeKey,userId);
        }*/
       redisTemplate.execute(new SessionCallback() {

           @Override
           public Object execute(RedisOperations operations) throws DataAccessException {
               String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
               String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);
               Boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);

               operations.multi();//开启事务
               if (isMember){
                   //已点赞  取消
                   operations.opsForSet().remove(entityLikeKey,userId);
                   operations.opsForValue().decrement(userLikeKey);//减少用户点赞数量
               }else {
                   //未点赞  点赞
                   operations.opsForSet().add(entityLikeKey,userId);
                   operations.opsForValue().increment(userLikeKey); //增加用户点赞数量
               }


               return  operations.exec();//执行事务
           }
       });

    }

    /**
     * 查询实体点赞的数量
     * @param entityType  给点赞的类型 1为帖子   2为评论和回复
     * @param entityId
     * @return
     */
    public long findEntityLikeCount(int entityType,int entityId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        return redisTemplate.opsForSet().size(entityLikeKey);
    }

    //查询某人对某实体的点赞状态  有没有点过赞
    public int findEntityLikeStatus(int userId,int entityType,int entityId){
        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);
        return redisTemplate.opsForSet().isMember(entityLikeKey,userId) ? 1:0;  //1点赞  0未点赞
    }

    /**
     *  查询某个用户获得的赞
     * @param userId 用户id
     * @return
     */
    public int findUserLikeCount(int userId){
        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);
        Integer count  = (Integer) redisTemplate.opsForValue().get(userLikeKey);
        return count == null ? 0 : count.intValue();

    }
}

```



### 1.3 LikeController

``` java
package com.justodit.controller;
//点赞
import com.justodit.entity.User;
import com.justodit.service.LikeService;
import com.justodit.util.HostHolder;
import com.justodit.util.JustDoItUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.HashMap;
import java.util.Map;

@Controller
public class LikeController {

    @Autowired
    private LikeService likeService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(value = "/like",method = RequestMethod.POST)
    @ResponseBody
    public String like(int entityType,int entityId,int entityUserId){
        User user = hostHolder.getUser();

        //点赞 并增加,减少用户的点赞数量
        likeService.like(user.getId(),entityType,entityId,entityUserId);
        //数量
        long likeCount = likeService.findEntityLikeCount(entityType,entityId);
        //状态
        int likeStatus = likeService.findEntityLikeStatus(user.getId(),entityType,entityId);

        Map<String,Object> map = new HashMap<>();
        map.put("likeCount",likeCount);
        map.put("likeStatus",likeStatus);

        return JustDoItUtil.getJsonString(0,null,map);
    }

}

```



### 1.4 HomeController

![image-20200902140926777](imgaes/image-20200902140926777.png)



### 1.5 页面

![image-20200902141158934](imgaes/image-20200902141158934.png)

![image-20200902141223133](imgaes/image-20200902141223133.png)

![image-20200902141304722](imgaes/image-20200902141304722.png)

**js：**

![image-20200902141524562](imgaes/image-20200902141524562.png)



## 2.开发个人主页

​		**--以用户为key，查询点赞数量**

UserController

``` java
/**
     *个人主页
     * @param userId
     * @param model
     * @return
     */
    @RequestMapping(value = "/profile/{userId}",method = RequestMethod.GET)
    public String getProfile(@PathVariable("userId")int userId, Model model){

        User user  = userService.findUserById(userId);
        if (user == null){
            throw new RuntimeException("该用户不存在");
        }

        //用户
        model.addAttribute("user",user);
        //用户收到点赞的数量
        int userLikeCount = likeService.findUserLikeCount(userId);
        model.addAttribute("likeCount",userLikeCount);

        return "/site/profile";

    }

```





``` html
<!-- 个人信息 -->
				<div class="media mt-5">
					<img th:src="${user.headerUrl}" class="align-self-start mr-4 rounded-circle" alt="用户头像" style="width:50px;">
					<div class="media-body">
						<h5 class="mt-0 text-warning">
							<span th:utext="${user.username}">nowcoder</span>
							<button type="button" class="btn btn-info btn-sm float-right mr-5 follow-btn">关注TA</button>
						</h5>
						<div class="text-muted mt-3">
							<span>注册于 <i class="text-muted" th:text="${#dates.format(user.createTime,'yyyy-MM-dd HH:mm:ss')}">2015-06-12 15:20:12</i></span>
						</div>
						<div class="text-muted mt-3 mb-5">
							<span>关注了 <a class="text-primary" href="followee.html">5</a> 人</span>
							<span class="ml-4">关注者 <a class="text-primary" href="follower.html">123</a> 人</span>
							<span class="ml-4">获得了 <i class="text-danger" th:text="${likeCount}">87</i> 个赞</span>
						</div>
					</div>
				</div>
```





# 四、关注，取消关注--redis

需求

​		--开发关注，取消关注功能

​		--统计用户的关注数，粉丝数

**关键**

​		**--若A关注B，则A是B的Follower（粉丝），B是A的Followee（目标）。**

​		**--关注的目标可以是用户，帖子，题目等，在是现实将这些目标抽象为实体  用户为3**



## 1.RedisKeyUtil



```java
package com.justodit.util;

import java.awt.image.renderable.RenderableImage;

public class RedisKeyUtil {

    private static final String SPLIT = ":";
    private static final String PREFIX_ENTITY_LIKE = "like:entity";
    private static final String PREFIX_USER_LIKE  = "like:user";

    private static final String PREFIX_FOLLOWEE = "followee";//目标
    private static final String PREFIX_FOLLOWER = "follower";//粉丝


    //某个实体的赞
    //like:entity:entityType:entityId ---> set(userId)
    public static String getEntityLikeKey(int entityType,int entityId){
        return  PREFIX_ENTITY_LIKE +SPLIT + entityType  + SPLIT + entityId;
    }

    //某个用户的赞
    //like:user:userId ----> int
    public static String getUserLikeKey(int userId){
        return PREFIX_USER_LIKE + SPLIT + userId;
    }


    //某个用户关注的实体
    //followee:userId:entityType  ----> zset(entityId,now)
    public static String getFolloweeKey(int userId,int entityType){
        return PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;

    }

    //某个实体拥有的粉丝
    //follower:entityType:entityId-----> zset(userId,now)
    public static String getFollowerKey(int entityType,int entityId){
        return PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;
    }


}

```



## 2.FollowService



``` java
package com.justodit.service;

import com.justodit.util.RedisKeyUtil;
import org.omg.CORBA.INTERNAL;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.core.RedisOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.SessionCallback;
import org.springframework.stereotype.Service;


//关注 取关
@Service
public class FollowService {

    @Autowired
    private RedisTemplate redisTemplate;


    /**
     * 关注
     * @param userId   用户id
     * @param entityType  用户关注实体的类型 用户类型为3  Constant常量接口中设置了
     * @param entityId  用户关注实体的id
     */
    public void follow(Integer userId, Integer entityType, Integer entityId){
        redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {

                String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);
                String followerKey = RedisKeyUtil.getFollowerKey(entityType,entityId);

                operations.multi();//启用事务

                operations.opsForZSet().add(followeeKey,entityId,System.currentTimeMillis());
                operations.opsForZSet().add(followerKey,userId,System.currentTimeMillis());

                return operations.exec();
            }
        });

    }


    /**
     * 取消关注
     * @param userId  用户id
     * @param entityType    实体类型  用户是3
     * @param entityId   实体id
     */
    public void unfollow(Integer userId,Integer entityType,Integer entityId){
        redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {

                String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);
                String followerKey = RedisKeyUtil.getFollowerKey(entityType,entityId);

                operations.multi();//启用事务

                operations.opsForZSet().remove(followeeKey,entityId);
                operations.opsForZSet().remove(followerKey,userId);

                return operations.exec();
            }
        });

    }


    /**
     *  查询用户关注的实体的数量
     * @param userId  用户id
     * @param entityType  实体类型 用户类型为3
     * @return
     */
    public long findFolloweeCount(int userId,int entityType){
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);
        return redisTemplate.opsForZSet().zCard(followeeKey);
    }

    /**
     * 查询某个实体的粉丝数量
     * @param entityId  实体id
     * @param entityType  实体类型  用户为3
     * @return
     */
    public long findFollowerCount(int entityId,int entityType){
        String followerKey = RedisKeyUtil.getFollowerKey(entityType,entityId);

        return redisTemplate.opsForZSet().zCard(followerKey);
    }

    /**
     * 查询当前用户是否已关注该实体  这里通过查询是否有score判断是否关注
     * @param userId  用户id
     * @param entityType   实体类型
     * @param entityId   实体id
     * @return
     */
    public boolean hasFollowed(int userId,int entityType,int entityId){
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);
        return redisTemplate.opsForZSet().score(followeeKey,entityId) != null;
    }

}


```

Constant常量接口

![image-20200902193230326](imgaes/image-20200902193230326.png)



## 3.FollowContoller



``` java
package com.justodit.controller;

import com.justodit.annotation.LoginRequired;
import com.justodit.entity.User;
import com.justodit.service.FollowService;
import com.justodit.util.HostHolder;
import com.justodit.util.JustDoItUtil;
import org.omg.CORBA.INTERNAL;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class FollowController {

    @Autowired
    private FollowService followService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(value = "/follow",method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    public String follow(Integer entityType,Integer entityId){
        User user = hostHolder.getUser();

        followService.follow(user.getId(),entityType,entityId);

        return JustDoItUtil.getJsonString(0,"已关注");
    }

    @RequestMapping(value = "/unfollow",method = RequestMethod.POST)
    @ResponseBody
    @LoginRequired
    public String unfollow(Integer entityType, Integer entityId){
        User user = hostHolder.getUser();

        followService.unfollow(user.getId(),entityType,entityId);

        return JustDoItUtil.getJsonString(0,"已取消关注");
    }



}

```



## 4.UserController

个人主页显示获赞数量

``` java
 /**
     *个人主页
     * @param userId
     * @param model
     * @return
     */
    @RequestMapping(value = "/profile/{userId}",method = RequestMethod.GET)
    public String getProfile(@PathVariable("userId")int userId, Model model){

        User user  = userService.findUserById(userId);
        if (user == null){
            throw new RuntimeException("该用户不存在");
        }

        //用户
        model.addAttribute("user",user);
        //用户收到点赞的数量
        int userLikeCount = likeService.findUserLikeCount(userId);
        model.addAttribute("likeCount",userLikeCount);

        //关注数量
        long followeeCount = followService.findFolloweeCount(userId, ENTITY_TYPE_USER);
        model.addAttribute("followeeCount",followeeCount);
        //粉丝数量
        long followerCount = followService.findFollowerCount(userId, ENTITY_TYPE_USER);
        model.addAttribute("followerCount",followerCount);
        //当前登录用户是否对该用户关注
        boolean hasFollowed = false;
        if (hostHolder.getUser() != null){
            hasFollowed = followService.hasFollowed(hostHolder.getUser().getId(),ENTITY_TYPE_USER,userId);
        }

        model.addAttribute("hasFollowed",hasFollowed);
        return "/site/profile";

    }

```



## 4.页面

![image-20200902193358495](imgaes/image-20200902193358495.png)

profile.js



```js
$(function(){
	$(".follow-btn").click(follow);
});

function follow() {
	var btn = this;
	if($(btn).hasClass("btn-info")) {
		// 关注TA   prev()获取当前节点的上一个节点
		$.post({
			url:"/follow",
			data:{"entityType":3,"entityId":$(btn).prev().val()},
			success:function (data) {
				data = $.parseJSON(data);
				if (data.code == 0){
					window.location.reload();
				}else {
					alert(data.msg);
				}
			}
		});

		//$(btn).text("已关注").removeClass("btn-info").addClass("btn-secondary");
	} else {
		// 取消关注
		$.post({
			url:"/unfollow",
			data:{"entityType":3,"entityId":$(btn).prev().val()},
			success:function (data) {
				data = $.parseJSON(data);
				if (data.code == 0){
					window.location.reload();
				}else {
					alert(data.msg);
				}
			}
		});
		//$(btn).text("关注TA").removeClass("btn-secondary").addClass("btn-info");
	}
}
```





# 五、关注列表、粉丝列表

业务层

​		--查询某个用户关注的人，支持分页

​		--查询某个用户的粉丝，支持分页



表现层

​		--处理“查询关注的人”，“查询粉丝”请求。

​		--编写“查询关注的人”，“查询粉丝”模板。

![image-20200902220315789](imgaes/image-20200902220315789.png)



## 1.FollowService



``` java
    /**
     * 查询某个用户关注的人 关注列表 分页
     * @param userId  用户id
     * @param offset  起始
     * @param limit  结束
     * @return
     */
    public List<Map<String,Object>> findFollowees(int userId,int offset,int limit){
        String followeeKey = RedisKeyUtil.getFolloweeKey(userId,ENTITY_TYPE_USER);
        Set<Integer> targetIds =  redisTemplate.opsForZSet().reverseRange(followeeKey,offset,offset+limit-1);//倒叙查询
        if (targetIds==null){
            return null;
        }
        List<Map<String,Object>> list = new ArrayList<>();
        for (Integer targetId : targetIds){
            Map<String,Object> map = new HashMap<>();
            User user = userService.findUserById(targetId);
            map.put("user",user);
            Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);//原先存的score为当前时间
            map.put("followTime",new Date(score.longValue()));
            list.add(map);

        }
        return list;

    }

    /**
     * 查询某用户的粉丝 粉丝列表  分页
     * @param userId 用户id
     * @param offset  起始
     * @param limit  结束
     * @return
     */
    public List<Map<String,Object>> findFollowers(int userId,int offset,int limit){
        String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER,userId);
        Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);
        if (targetIds == null){
            return null;
        }
        List<Map<String, Object>> list = new ArrayList<>();
        for (Integer targetId:targetIds){
            Map<String,Object> map = new HashMap<>();
            User user = userService.findUserById(targetId);
            map.put("user",user);
            Double score = redisTemplate.opsForZSet().score(followerKey, targetId);
            map.put("followTime",new Date(score.longValue()));
            list.add(map);
        }
        return list;
    }
```



## 2.FollowController

```java
 /**
     * 关注列表
     * @param userId  用户id
     * @param page   分页
     * @param model
     * @return
     */
    @RequestMapping(value = "/followees/{userId}",method = RequestMethod.GET)
    public String getFollowees(@PathVariable("userId") int userId, Page page, Model model){
        User user = userService.findUserById(userId);
        if (user == null){
            throw new RuntimeException("该用户不存咋");
        }
        model.addAttribute("user",user);

        //分页信息
        page.setLimit(5);
        page.setPath("/followees/"+ userId);
        page.setRows((int) followService.findFolloweeCount(userId,ENTITY_TYPE_USER));

        //查询关注列表
        List<Map<String,Object>> userList = followService.findFollowees(userId,page.getOffset(),page.getLimit());
        if (userList != null){
            for (Map<String,Object> map:userList){
                User u = (User) map.get("user");
                //判断当前登录用户是否关注该用户
                map.put("hasFollowed",hasFollowed(u.getId()));

            }
        }
        model.addAttribute("users",userList);

        return "/site/followee";
    }


    /**
     * 粉丝列表
     * @param userId  用户id
     * @param page   分页
     * @param model
     * @return
     */
    @RequestMapping(value = "/followers/{userId}",method = RequestMethod.GET)
    public String getFollowers(@PathVariable("userId") int userId, Page page, Model model){
        User user = userService.findUserById(userId);
        if (user == null){
            throw new RuntimeException("该用户不存咋");
        }
        model.addAttribute("user",user);

        //分页信息
        page.setLimit(5);
        page.setPath("/followers/"+ userId);
        page.setRows((int) followService.findFollowerCount(userId,ENTITY_TYPE_USER));

        //查询关注列表
        List<Map<String,Object>> userList = followService.findFollowers(userId,page.getOffset(),page.getLimit());
        if (userList != null){
            for (Map<String,Object> map : userList){
                User u = (User) map.get("user");
                //判断当前登录用户是否关注该用户
                map.put("hasFollowed",hasFollowed(u.getId()));

            }
        }
        model.addAttribute("users",userList);

        return "/site/follower";
    }

    //判断当前用户关注的状态
    private boolean hasFollowed(int userId){
        if (hostHolder.getUser() == null){
            return false;
        }
        return followService.hasFollowed(hostHolder.getUser().getId(),ENTITY_TYPE_USER,userId);

    }

```



## 3.页面

prifile.html  个人中心

![image-20200902221014542](imgaes/image-20200902221014542.png)



followee.html 关注列表

``` html
<!-- 内容 -->
		<div class="main">
			<div class="container">
				<div class="position-relative">
					<!-- 选项 -->
					<ul class="nav nav-tabs mb-3">
						<li class="nav-item">
							<a class="nav-link position-relative active" th:href="@{|/followees/${user.id}|}">
								<i class="text-info" th:utext="${user.username}">Nowcoder
								</i> 关注的人
							</a>
						</li>
						<li class="nav-item">
							<a class="nav-link position-relative" th:href="@{|/followers/${user.id}|}">关注
								<i class="text-info" th:utext="${user.username}">Nowcoder
								</i> 的人
							</a>
						</li>
					</ul>
					<a th:href="@{|/user/profile/${user.id}|}" class="text-muted position-absolute rt-0">返回个人主页&gt;</a>
				</div>
				
				<!-- 关注列表 -->
				<ul class="list-unstyled">
					<li class="media pb-3 pt-3 mb-3 border-bottom position-relative" th:each="map:${users}">
						<a th:href="@{|/user/profile/${map.user.id}|}">
							<img th:src="${map.user.headerUrl}" class="mr-4 rounded-circle user-header" alt="用户头像" >
						</a>
						<div class="media-body">
							<h6 class="mt-0 mb-3">
								<span class="text-success" th:text="${map.user.username}">落基山脉下的闲人</span>
								<span class="float-right text-muted font-size-12">关注于
									<i th:text="${#dates.format(map.followTime,'yyyy-MM-dd HH:mm:ss')}">2019-04-28 14:13:25</i>
								</span>
							</h6>
							<div>
								<input type="hidden" id="entityId" th:value="${map.user.id}">
								<button type="button" th:class="|btn ${map.hasFollowed?'btn-secondary':'btn-info'} btn-sm float-right follow-btn|"
								th:if="${loginUser!=null && loginUser.id!= map.user.id}" th:text="${map.hasFollowed?'已关注':'关注'}">关注TA</button>
							</div>
						</div>
					</li>
				</ul>
```



follower.html 粉丝列表

``` java
<!-- 内容 -->
		<div class="main">
			<div class="container">
				<div class="position-relative">
					<!-- 选项 -->
					<ul class="nav nav-tabs mb-3">
						<li class="nav-item">
							<a class="nav-link position-relative" th:href="@{|/followees/${user.id}|}">
								<i class="text-info" th:utext="${user.username}">Nowcoder
								</i> 关注的人
							</a>
						</li>
						<li class="nav-item">
							<a class="nav-link position-relative active" th:href="@{|/followers/${user.id}|}">关注
								<i class="text-info">Nowcoder
								</i> 的人
							</a>
						</li>
					</ul>
					<a th:href="@{|/user/profile/${user.id}|}" class="text-muted position-absolute rt-0">返回个人主页&gt;</a>
				</div>
				
				<!-- 粉丝列表 -->
				<ul class="list-unstyled">
					<li class="media pb-3 pt-3 mb-3 border-bottom position-relative" th:each="map:${users}">
						<a th:href="@{|/user/profile/${map.user.id}|}">
							<img th:src="${map.user.headerUrl}" class="mr-4 rounded-circle user-header" alt="用户头像" >
						</a>
						<div class="media-body">
							<h6 class="mt-0 mb-3">
								<span class="text-success" th:utext="${map.user.username}">落基山脉下的闲人</span>
								<span class="float-right text-muted font-size-12">关注于
									<i th:text="${#dates.format(map.followTime,'yyyy:MM:dd HH:mm:ss')}">2019-04-28 14:13:25</i>
								</span>
							</h6>
							<div>
								<input type="hidden" id="entityId" th:value="${map.user.id}">
								<button type="button" th:class="|btn ${map.hasFollowed?'btn-secondary':'btn-info'} btn-sm float-right follow-btn|"
										th:if="${loginUser!=null && loginUser.id!= map.user.id}" th:text="${map.hasFollowed?'已关注':'关注'}">关注TA</button>
							</div>
						</div>
					</li>
				</ul>
```





# 六、优化登录模块---redis

## 1.使用Redis存储验证码

​		**--验证码需要频繁的访问与刷新，对性能要求较高**

​		**--验证码不需要永久保存，通常在很短的时间就会失效**

​		**--分布式部署时，存在Session共享问题**

### 1.1 RedisKeyUtil



![image-20200903210815407](imgaes/image-20200903210815407.png)

![image-20200903210830736](imgaes/image-20200903210830736.png)



### 1.2 LoginController

将生成的验证码存放到redis中，并且含有用户归属，用户登陆时，从redis中取出验证码进行比较

``` java
    /**kaptcha 生成验证码
     *
     * @param response
     * @param
     */
    @RequestMapping(value = "/kaptcha",method = RequestMethod.GET)
    public void  getKaptcha(HttpServletResponse response/*, HttpSession session*/){

        //生成验证码
        String text = kaptchaProducer.createText();
        BufferedImage image = kaptchaProducer.createImage(text);

        //将验证码存放到session中
        //session.setAttribute("kaptcha",text);

        //将验证码存到Redis中
        //验证码的归属
        String kaptchaOwner = JustDoItUtil.generateUUId();
        Cookie cookie  = new Cookie("kaptcharOwner",kaptchaOwner);
        cookie.setMaxAge(60);
        cookie.setPath("/");
        response.addCookie(cookie);
        //将验证码存入redis
        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);
        redisTemplate.opsForValue().set(redisKey,text,60, TimeUnit.SECONDS);



        //将图片输出给浏览器中
        response.setContentType("image/png");
        try {
            OutputStream os = response.getOutputStream();
            ImageIO.write(image,"png",os);
        } catch (IOException e) {
            logger.error("响应验证码失败 :"+e.getMessage());
        }
    }

/**
     *登录
     * @param username  用户名
     * @param password  密码
     * @param code   验证码
     * @param rememberme   记住我
     * //@param  session    用于和session中的验证码比较
     * @param response  将登录凭证发送到客户端保存
     * @param kaptcharOwner  登录重构后 用于从cookie中获取该用户的验证码
     * @return
     */
    @PostMapping("/login")//传进来分装成对象如User,model将自动存到model里,如果是基本类型,可以从request中取
    public String login(String username,String password,String code,Boolean rememberme,
                        Model model/*,HttpSession session*/,HttpServletResponse response,HttpServletRequest request,@CookieValue("kaptcharOwner") String kaptcharOwner){

        //判断验证码
        if (rememberme==null) rememberme=false;
        //String kaptcha = (String) session.getAttribute("kaptcha");
        String kaptcha = null;
        if (StringUtils.isNotBlank(kaptcharOwner)){
            //从redis中获取验证码
            String redisKey = RedisKeyUtil.getKaptchaKey(kaptcharOwner);
             kaptcha = (String) redisTemplate.opsForValue().get(redisKey);
        }

        if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)){
            model.addAttribute("codeMsg","验证码不正确");
            return "/site/login";
        }

        //检查账号,密码
        int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
        Map<String ,Object> map = userService.login(username,password,expiredSeconds);
        if (map.containsKey("ticket")){
            Cookie cookie = new Cookie("ticket",map.get("ticket").toString());
            cookie.setPath(request.getContextPath());
            cookie.setMaxAge(expiredSeconds);
            response.addCookie(cookie);
            return "redirect:/index";
        }else {
            model.addAttribute("usernameMsg",map.get("usernameMsg"));
            model.addAttribute("passwordMsg",map.get("passwordMsg"));
            return "/site/login";
        }

    }

```





## 2.使用Redis存储登录凭证

​		**--处理每次请求时，都要查询用户的登录凭证，访问的频率非常高**

​		**以前写的LoginTicketMapper将废弃**

### 2.1RedisKeyUtil

![image-20200903211402750](imgaes/image-20200903211402750.png)

![image-20200903211438380](imgaes/image-20200903211438380.png)



### 2.2 UserService

用户登陆时，将生成登录凭证存放到redis中。退出时，将status设置为1



``` java
    /**
     * 登录
     * @param username 账号
     * @param password  密码  用户注册时使用md5进行加密,所以登陆时要对密码页进行md5加密进行比较
     * @param expiredSeconds  过期时间
     * @return
     */
    public Map<String,Object> login(String username,String password,int expiredSeconds){

        Map<String,Object> map = new HashMap<>();
        //空值处理
        if (StringUtils.isBlank(username)){
            map.put("usernameMsg","账号不能为空");
            return map;
        }
        if (StringUtils.isBlank(password)){
            map.put("passwordMsg","密码不能为空!");
            return map;
        }

        //验证账号
        User user = userMapper.selectByName(username);
        if (user == null){
            map.put("usernameMsg","该账号不存在");
            return map;
        }
        //验证状态
        if (user.getStatus() == 0){
            map.put("usernameMsg","该账号未激活");
            return map;
        }
        //验证密码
        password = JustDoItUtil.md5(password+user.getSalt());
        if (!user.getPassword().equals(password)){
            map.put("passwordMsg","密码不正确");
            return map;
        }

        //生成登录凭证
        LoginTicket loginTicket = new LoginTicket();
        loginTicket.setUserId(user.getId());
        loginTicket.setTicket(JustDoItUtil.generateUUId());
        loginTicket.setStatus(0);

        loginTicket.setExpired(new Date(new Date().getTime() + expiredSeconds*1000));
        System.out.println(loginTicket.getExpired());
       // loginTicketMapper.insertLoginTicket(loginTicket);

        //将登录凭证存放到Redis中
        String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());
        redisTemplate.opsForValue().set(redisKey,loginTicket);

        //登录凭证发送给客户端,用于下次登录检测
        map.put("ticket",loginTicket.getTicket());

        return map;
    }

    /**
     *退出  将状态设置为1
     */
    public void logOut(String ticket){
        //loginTicketMapper.updateStatus(ticket,1);
        String redisKey = RedisKeyUtil.getTicketKey(ticket);
         LoginTicket loginTicket  = (LoginTicket) redisTemplate.opsForValue().get(redisKey);
         loginTicket.setStatus(1);//状态1表示禁用
        redisTemplate.opsForValue().set(redisKey,loginTicket);
    }

 /**
     * 根据ticket查询登录凭证
     * @param ticket
     * @return
     */
    public LoginTicket findLoginTicket(String ticket){
        //return loginTicketMapper.selectByTicket(ticket);
        String redisKey = RedisKeyUtil.getTicketKey(ticket);
        return  (LoginTicket)redisTemplate.opsForValue().get(redisKey);
    }
```



## 3.使用Redis缓存用户信息

​		**--每次请求时，都要根据凭证查询用户信息，访问频率非常高**

​	

### 3.1RedisKeyUtil

![image-20200903212724906](imgaes/image-20200903212724906.png)

![image-20200903212741871](imgaes/image-20200903212741871.png)



### 3.2 UserService

当调用findUserById时，先从redis中查询，若没有数据，则从数据库中查询，然后存放到redis中

当我们修改用户的信息是，如修改登录凭证，用户头像时，要将redis中的数据清除

```java
    //根据discuss_post 中的userid查询
    public User findUserById(int id){
       // return userMapper.selectById(id);
        User user = getCache(id);
        if (user == null){
            user = initCache(id);
        }
        return user;

    }

  /**
     * 将用户信息存放到Redis中
     * 1.优先从缓存中取值
     */
    private User getCache(int userId){
        String redisKey = RedisKeyUtil.getUserKey(userId);
        return (User) redisTemplate.opsForValue().get(redisKey);


    }
       //2.取不到时就初始化缓存数据
    private User initCache(int userId){
        User user = userMapper.selectById(userId);
        String redisKey = RedisKeyUtil.getUserKey(userId);
        redisTemplate.opsForValue().set(redisKey,user,3600, TimeUnit.SECONDS);
        return user;

    }
    //3.当数据变更时,清除缓存数据
    private void clearCache(int userId){
        String redisKey = RedisKeyUtil.getUserKey(userId);
        redisTemplate.delete(redisKey);
    }
```

![image-20200903213305545](imgaes/image-20200903213305545.png)

![image-20200903213353969](imgaes/image-20200903213353969.png)

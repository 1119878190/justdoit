# 一.过滤敏感词---前缀树



**前缀树：**

​		名称：Trie，字典树，查找树

​		特点： 查询效率高，消耗内存大

​		应用： 字符串检索，词频统计，字符串排序





![image-20200822175233697](imgaes/image-20200822175233697.png)

三个指针 

前缀树根节点是空的，其他节点只包含一个字符

从根节点到某一个节点经过的路径上就是这个节点对应的字符串

每一个节点的所有的子节点包含的字符不一样，一样的要合并





**敏感词过滤器**

## 0.创建文件txt定义敏感词

![image-20200822204524558](imgaes/image-20200822204524558.png)

## 1.定义前缀树

``` java
//敏感词过滤器
@Component
public class SensitiveFilter {
    
    
    /**
     * 前缀树
     */
    private class  TrieNode{

        //关键词结束表示
        private boolean isKeyWordEnd = false;

        //子节点  key是下级字符,value是下级节点
        private Map<Character,TrieNode> subNodes = new HashMap<>();

        public boolean isKeyWordEnd() {
            return isKeyWordEnd;
        }

        public void setKeyWordEnd(boolean keyWordEnd) {
            isKeyWordEnd = keyWordEnd;
        }

        //添加子节点
        public void addSubNode(Character c,TrieNode node){
            subNodes.put(c,node);
        }

        //获取子节点
        public TrieNode getSubNode(Character character){
            return subNodes.get(character);
        }

    }
}
    
    
```



## 2.根据敏感词，初始化前缀树

``` java
//敏感词过滤器
@Component
public class SensitiveFilter {


    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    //替换符
    private static final String REPLACEMENT = "***";

    //根节点
    private TrieNode rootNode = new TrieNode();

    @PostConstruct //服务启动时调用
    public void init(){

        try (
            InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));//字符流
        ) {
           String keyWord;
           while ((keyWord = reader.readLine()) != null){

               //添加到前缀数中
               this.addKeyWord(keyWord);
           }

        } catch (Exception e) {
            logger.error("加载敏感词文件失败"+e.getMessage());
        }

    }

    /**
     * 将一个敏感词添加到前缀数中
     * @param keyWord
     */
    private void addKeyWord(String keyWord){
        TrieNode tempNode = rootNode; //指针,默认指向根
        for (int i = 0; i < keyWord.length() ;i++){
            char c = keyWord.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if (subNode == null){
                //如果子节点不存在,就创建,将字符挂载到节点上
                subNode = new TrieNode();
                tempNode.addSubNode(c,subNode);
            }
            //指针指向子节点,进入下一轮循环
            tempNode = subNode;

            //设置结束的标识
            if (i == keyWord.length()-1){
                tempNode.setKeyWordEnd(true);
            }
        }
    }

```





## 3.编写过滤敏感词的方法

``` java
 /**
     * 过滤敏感词
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text){
        if (StringUtils.isBlank(text)){
            return null;
        }

        //指针1 指向树
        TrieNode tempNode = rootNode;
        //指针2 指向字符串
        int begin = 0;
        //指针3
        int position = 0;
        //结果
        StringBuilder sb = new StringBuilder();

        while (position < text.length()){
            char c = text.charAt(position);

            //跳过特殊符号
            if(isSymbol(c)){
                //若指针1处于跟节点,将此字符计入结果,让指针2走向下一步
                if (tempNode == rootNode){
                    sb.append(c);
                    begin++;
                }
                //无论符号在开头或中间,指针三都向下走一步
                position++;
                continue;
            }

            //不是符号,检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null){
            //没有该节点以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                //指针2进入下一个位置,指针3和指针2保持同一个位置
                position = ++ begin;
                //指针1重新指向跟节点
                tempNode = rootNode;
            }else if (tempNode.isKeyWordEnd()){
             //发现了敏感词,将begin~position该段的字符串替换掉
                sb.append(REPLACEMENT);
                //进入到下一个位置
                begin = ++ position;
                //重新指向根节点
                tempNode = rootNode;
            }else {
                //继续检查下一个字符
                position++;
            }

        }
        //将最后一批字符计入结果
        sb.append(text.substring(begin));

        return sb.toString();

    }

    /**
     * 判断是否为符号
     * @param c
     * @return
     */
    private boolean isSymbol(Character c){
        //0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }

```



## 4.完整代码：

``` java
package com.justodit.util;

import org.apache.commons.lang3.CharUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

//敏感词过滤器
@Component
public class SensitiveFilter {


    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    //替换符
    private static final String REPLACEMENT = "***";

    //根节点
    private TrieNode rootNode = new TrieNode();

    @PostConstruct //服务启动时调用
    public void init(){

        try (
            InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));//字符流
        ) {
           String keyWord;
           while ((keyWord = reader.readLine()) != null){

               //添加到前缀数中
               this.addKeyWord(keyWord);
           }

        } catch (Exception e) {
            logger.error("加载敏感词文件失败"+e.getMessage());
        }

    }

    /**
     * 将一个敏感词添加到前缀数中
     * @param keyWord
     */
    private void addKeyWord(String keyWord){
        TrieNode tempNode = rootNode; //指针,默认指向根
        for (int i = 0; i < keyWord.length() ;i++){
            char c = keyWord.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if (subNode == null){
                //如果子节点不存在,就创建,将字符挂载到节点上
                subNode = new TrieNode();
                tempNode.addSubNode(c,subNode);
            }
            //指针指向子节点,进入下一轮循环
            tempNode = subNode;

            //设置结束的标识
            if (i == keyWord.length()-1){
                tempNode.setKeyWordEnd(true);
            }
        }
    }

    /**
     * 过滤敏感词
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text){
        if (StringUtils.isBlank(text)){
            return null;
        }

        //指针1 指向树
        TrieNode tempNode = rootNode;
        //指针2 指向字符串
        int begin = 0;
        //指针3
        int position = 0;
        //结果
        StringBuilder sb = new StringBuilder();

        while (position < text.length()){
            char c = text.charAt(position);

            //跳过特殊符号
            if(isSymbol(c)){
                //若指针1处于跟节点,将此字符计入结果,让指针2走向下一步
                if (tempNode == rootNode){
                    sb.append(c);
                    begin++;
                }
                //无论符号在开头或中间,指针三都向下走一步
                position++;
                continue;
            }

            //不是符号,检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null){
            //没有该节点以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                //指针2进入下一个位置,指针3和指针2保持同一个位置
                position = ++ begin;
                //指针1重新指向跟节点
                tempNode = rootNode;
            }else if (tempNode.isKeyWordEnd()){
             //发现了敏感词,将begin~position该段的字符串替换掉
                sb.append(REPLACEMENT);
                //进入到下一个位置
                begin = ++ position;
                //重新指向根节点
                tempNode = rootNode;
            }else {
                //继续检查下一个字符
                position++;
            }

        }
        //将最后一批字符计入结果
        sb.append(text.substring(begin));

        return sb.toString();

    }

    /**
     * 判断是否为符号
     * @param c
     * @return
     */
    private boolean isSymbol(Character c){
        //0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }

    /**
     * 前缀树
     */
    private class  TrieNode{

        //关键词结束表示
        private boolean isKeyWordEnd = false;

        //子节点  key是下级字符,value是下级节点
        private Map<Character,TrieNode> subNodes = new HashMap<>();

        public boolean isKeyWordEnd() {
            return isKeyWordEnd;
        }

        public void setKeyWordEnd(boolean keyWordEnd) {
            isKeyWordEnd = keyWordEnd;
        }

        //添加子节点
        public void addSubNode(Character c,TrieNode node){
            subNodes.put(c,node);
        }

        //获取子节点
        public TrieNode getSubNode(Character character){
            return subNodes.get(character);
        }

    }
}

```





# 二.发布帖子--Ajax



``` xlm
<!-- fastjson -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.58</version>
        </dependency>
```



## 1.工具类，用户获取Json字符串

用于用户发布后的提示信息

``` java
package com.justodit.util;

import com.alibaba.fastjson.JSONObject;
import org.apache.commons.lang3.StringUtils;
import org.springframework.util.DigestUtils;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class JustDoItUtil {

  

    /**
     *获取Json格式的字符串  fastJson
     * @param code 编号
     * @param msg  提示
     * @param map  数据
     * @return
     */
    public static String getJsonString(int code, String msg, Map<String,Object> map){
        JSONObject json = new JSONObject();
        json.put("code",code);
        json.put("msg",msg);
        if (map != null){
            for (String key : map.keySet()){
                json.put(key,map.get(key));
            }

        }
        return json.toJSONString();
    }

    public static String getJsonString(int code,String msg){
        return getJsonString(code,msg,null);
    }

    public static String getJsonString(int code){
        return getJsonString(code,null,null);
    }

}

```

## 2.Mapper 、Service

``` java
    <!-- 添加帖子   -->
    <insert id="insertDiscussPost" parameterType="com.justodit.entity.DiscussPost" keyProperty="id">
        insert into  discuss_post(<include refid="insertFields"></include>)
        values(#{userId},#{title},#{content},#{type},#{status},#{createTime},#{commentCount},#{score})
    </insert>
```



``` java
package com.justodit.service;


import com.justodit.dao.DiscussPostMapper;
import com.justodit.entity.DiscussPost;
import com.justodit.util.SensitiveFilter;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.util.HtmlUtils;


import java.util.List;

@Service
public class DiscussPostService {


    @Autowired
    private DiscussPostMapper discussPostMapper;

    @Autowired
    private SensitiveFilter sensitiveFilter;


    //添加帖子
    public int addDiscussPost(DiscussPost discussPost){
        if (discussPost == null){
            throw new IllegalArgumentException("参数不能为空");
        }

        //如果title和content中含有html标签,要转义
        discussPost.setTitle(HtmlUtils.htmlEscape(discussPost.getContent()));
        discussPost.setContent(HtmlUtils.htmlEscape(discussPost.getContent()));

        //敏感词过滤
        discussPost.setTitle(sensitiveFilter.filter(discussPost.getTitle()));
        discussPost.setContent(sensitiveFilter.filter(discussPost.getContent()));

        //插入数据
        return discussPostMapper.insertDiscussPost(discussPost);
    }
}

```

## 3.Controller



``` java
package com.justodit.controller;


import com.justodit.entity.DiscussPost;
import com.justodit.entity.User;
import com.justodit.service.DiscussPostService;
import com.justodit.util.HostHolder;
import com.justodit.util.JustDoItUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.Date;

@Controller
@RequestMapping("/discuss")
public class DiscussPostController {

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private HostHolder hostHolder;

    @PostMapping("/add")
    @ResponseBody
    public String addDiscussPost(String title,String content){
        User user = hostHolder.getUser();
        if (user == null){
            return JustDoItUtil.getJsonString(403,"你还没有登录");
        }

        DiscussPost discussPost = new DiscussPost();
        discussPost.setUserId(user.getId());
        discussPost.setTitle(title);
        discussPost.setContent(content);
        discussPost.setType(0);
        discussPost.setStatus(0);
        discussPost.setCommentCount(0);
        discussPost.setScore(0.0);
        discussPost.setCreateTime(new Date());
        discussPostService.addDiscussPost(discussPost);

        //报错的情况,将来用以处理
        return JustDoItUtil.getJsonString(0,"发布成功");
    }

}

```

## 4.页面

**Html**

``` html
<button type="button" class="btn btn-primary btn-sm position-absolute rt-0" data-toggle="modal" data-target="#publishModal" th:if="${loginUser!=null}">我要发布</button>
				</div>
				<!-- 弹出框 -->
				<div class="modal fade" id="publishModal" tabindex="-1" role="dialog" aria-labelledby="publishModalLabel" aria-hidden="true">
					<div class="modal-dialog modal-lg" role="document">
						<div class="modal-content">
							<div class="modal-header">
								<h5 class="modal-title" id="publishModalLabel">新帖发布</h5>
								<button type="button" class="close" data-dismiss="modal" aria-label="Close">
									<span aria-hidden="true">&times;</span>
								</button>
							</div>
							<div class="modal-body">
								<form>
									<div class="form-group">
										<label for="recipient-name" class="col-form-label">标题：</label>
										<input type="text" class="form-control" id="recipient-name">
									</div>
									<div class="form-group">
										<label for="message-text" class="col-form-label">正文：</label>
										<textarea class="form-control" id="message-text" rows="15"></textarea>
									</div>
								</form>
							</div>
							<div class="modal-footer">
								<button type="button" class="btn btn-secondary" data-dismiss="modal">取消</button>
								<button type="button" class="btn btn-primary" id="publishBtn">发布</button>
							</div>
						</div>
					</div>
				</div>
				<!-- 提示框 -->
				<div class="modal fade" id="hintModal" tabindex="-1" role="dialog" aria-labelledby="hintModalLabel" aria-hidden="true">
					<div class="modal-dialog modal-lg" role="document">
						<div class="modal-content">
							<div class="modal-header">
								<h5 class="modal-title" id="hintModalLabel">提示</h5>
							</div>
							<div class="modal-body" id="hintBody">
								发布完毕!
							</div>
						</div>
					</div>
				</div>
```





**js:**

``` js
$(function(){
	$("#publishBtn").click(publish);
});

function publish() {
	$("#publishModal").modal("hide");

	//获取标题和内容
	var title = $("#recipient-name").val();
	var content = $("#message-text").val();
	//发送异步请求post
	$.post({
		url:"/discuss/add",
		data:{"title":title,"content":content},
		success:function (data) {
			data = $.parseJSON(data);//将字符串转为json
			//提示框中显示返回的消息
			$("#hintBody").text(data.msg);
			//显示提示框
			$("#hintModal").modal("show");
			//2秒后自动隐藏提示框
			setTimeout(function(){
				$("#hintModal").modal("hide");
				//刷新页面
				if (data.code == 0){
					window.location.reload();
				}
			}, 2000);
		}

	});


}
```





# 三.帖子内容详情

## 1. Mapper

``` java
 <!-- 帖子详情   -->
    <select id="selectDiscussPostById" resultType="com.justodit.entity.DiscussPost" parameterType="integer">
        select <include refid="selectFields"></include>
        from discuss_post
        where id=#{id}
    </select>
```



## 2. Service

```java
  /**
     * 帖子详情
     * @param id
     * @return
     */
    public DiscussPost findDiscussPostById(Integer id){
        return discussPostMapper.selectDiscussPostById(id);
    }
```

## 3.Controller

查询作者的话也可以用多表查询

``` java
    /**
     * 帖子详情
     * @param discussPostId 帖子id
     * @param model
     * @return
     */
    @RequestMapping(value = "/detail/{discussPostId}",method = RequestMethod.GET)
    public String getDiscussPostById(@PathVariable("discussPostId")Integer discussPostId, Model model){

        //帖子
        DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
        model.addAttribute("post",post);

        //作者
        User user = userService.findUserById(post.getUserId());
        model.addAttribute("user",user);

        return "/site/discuss-detail";


    }
```





# 四.显示评论



![image-20200823124531250](imgaes/image-20200823124531250.png)

entity_type: 表示是对帖子的评论，还用对用户的回复 1表示帖子评论，2表示回复

entity_id	：具体是哪一个帖子

target_id	：对评论的回复的目标的id，指向人

status : 0表示有效，1表示无效

![image-20200823161256513](imgaes/image-20200823161256513.png)

## 1.数据层

根据具体查询一页评论数据

根据实体查询评论的数量

``` xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.justodit.dao.CommentMapper">

    <sql id="selectFields">
        id, user_id, entity_type, entity_id, target_id, content, status, create_time
    </sql>

<!--    查询评论-->
    <select id="selectCommentByEntity" resultType="com.justodit.entity.Comment" parameterType="integer">
        select <include refid="selectFields"></include>
        from comment
        where status=0
        and entity_type=#{entityType}
        and entity_id=#{entityId}
        order by create_time asc
        limit #{offset}, #{limit}
    </select>

<!--    查询总评论数-->
    <select id="selectCountByEntity" resultType="integer" parameterType="integer">
        select count(*)
        from comment
        where status=0
        and entity_type=#{entityType}
        and entity_id = #{entityId}
    </select>

</mapper>
```



常量接口

``` java
    /**
     * 实体类型:评论    帖子的评论
     */
    int ENTITY_TYPE_POST = 1;

    /**
     * 实体类型:回复    评论的评论
     */
    int ENTITY_TYPE_COMMENT = 2;
```



## 2.业务层

处理查询评论的业务

处理查询评论数量的业务

``` java
package com.justodit.service;

import com.justodit.dao.CommentMapper;
import com.justodit.entity.Comment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CommentService {

    @Autowired
    private CommentMapper commentMapper;


    /**
     * 查询帖子的评论
     * @param entityType  类型 帖子的评论1or评论的回复2
     * @param entityId   帖子id
     * @param offset    起始
     * @param limit      多少条
     * @return
     */
    public List<Comment> findCommentByEntity(Integer entityType,Integer entityId,Integer offset ,Integer limit){
        return commentMapper.selectCommentByEntity(entityType,entityId,offset,limit);
    }

    public int findCommentCount(Integer entityType,Integer entityId){
        return commentMapper.selectCountByEntity(entityType,entityId);
    }
}

```



## 3.表现出

显示帖子详情数据，同时显示该帖子所有的评论数据

``` java
package com.justodit.controller;


import com.justodit.entity.Comment;
import com.justodit.entity.DiscussPost;
import com.justodit.entity.Page;
import com.justodit.entity.User;
import com.justodit.service.CommentService;
import com.justodit.service.DiscussPostService;
import com.justodit.service.UserService;
import com.justodit.util.Constant;
import com.justodit.util.HostHolder;
import com.justodit.util.JustDoItUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import javax.jws.WebParam;
import java.util.*;

@Controller
@RequestMapping("/discuss")
public class DiscussPostController implements Constant {

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private UserService userService;

    @Autowired
    private CommentService commentService;

    /**
     * 发布帖子
     * @param title 标题
     * @param content  内容
     * @return
     */
    @PostMapping("/add")
    @ResponseBody
    public String addDiscussPost(String title,String content){
        User user = hostHolder.getUser();
        if (user == null){
            return JustDoItUtil.getJsonString(403,"你还没有登录");
        }

        DiscussPost discussPost = new DiscussPost();
        discussPost.setUserId(user.getId());
        discussPost.setTitle(title);
        discussPost.setContent(content);
        discussPost.setType(0);
        discussPost.setStatus(0);
        discussPost.setCommentCount(0);
        discussPost.setScore(0.0);
        discussPost.setCreateTime(new Date());
        discussPostService.addDiscussPost(discussPost);

        //报错的情况,将来用以处理

        return JustDoItUtil.getJsonString(0,"发布成功");
    }


    /**
     * 帖子详情
     * @param discussPostId 帖子id
     * @param model
     * @return
     */
    @RequestMapping(value = "/detail/{discussPostId}",method = RequestMethod.GET)
    public String getDiscussPostById(@PathVariable("discussPostId")Integer discussPostId, Model model, Page page){

        //帖子
        DiscussPost post = discussPostService.findDiscussPostById(discussPostId);
        model.addAttribute("post",post);

        //作者
        User user = userService.findUserById(post.getUserId());
        model.addAttribute("user",user);

        //评论分页信息
        page.setLimit(5);
        page.setPath("/discuss/detail/" + discussPostId);
        page.setRows(post.getCommentCount());

        //评论: 给帖子的评论
        //回复: 给评论的评论
        //评论的列表
        List<Comment> commentList = commentService.findCommentByEntity(
                                        ENTITY_TYPE_POST,post.getId(),page.getOffset(),page.getLimit());
        //评论的Vo列表 ViewObject
        List<Map<String,Object>> commentVoList = new ArrayList<>();
        if (commentList != null){
            for (Comment comment : commentList){
                //一个评论的VO  ViewObject
                Map<String,Object> commentVo = new HashMap<>();
                //评论
                commentVo.put("comment",comment);
                //评论的作者
                commentVo.put("user",userService.findUserById(comment.getUserId()));

                //回复列表  不分页查询
                List<Comment> replyList = commentService.findCommentByEntity(
                                            ENTITY_TYPE_COMMENT,comment.getId(),0,Integer.MAX_VALUE);
                //回复的VO列表
                List<Map<String,Object>> replyVoList = new ArrayList<>();
                if (replyList != null){
                    for (Comment reply: replyList){
                        Map<String,Object> replyVo = new HashMap<>();
                        //回复
                        replyVo.put("reply",reply);
                        replyVo.put("user",userService.findUserById(reply.getUserId()));
                        // 回复的目标 targetId
                        User target = reply.getTargetId()== 0 ? null: userService.findUserById(reply.getTargetId());
                        replyVo.put("target",target);

                        replyVoList.add(replyVo);
                    }
                }
                commentVo.put("replys",replyVoList);

                //回复数量
                int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT,comment.getId());
                commentVo.put("replyCount",replyCount);

                commentVoList.add(commentVo);
            }
        }

        model.addAttribute("comments",commentVoList);
        return "/site/discuss-detail";



    }





}

```



## 4.Html

``` java
<!-- 回帖 -->
			<div class="container mt-3">
				<!-- 回帖数量 -->
				<div class="row">
					<div class="col-8">
						<h6><b class="square"></b> <i th:text="${post.commentCount}">30</i>条回帖</h6>
					</div>
					<div class="col-4 text-right">
						<a href="#replyform" class="btn btn-primary btn-sm">&nbsp;&nbsp;回&nbsp;&nbsp;帖&nbsp;&nbsp;</a>
					</div>
				</div>
				<!-- 回帖列表 -->
				<ul class="list-unstyled mt-4">
					<li class="media pb-3 pt-3 mb-3 border-bottom" th:each="cvo:${comments}">
						<a href="profile.html">
							<img th:src="${cvo.user.headerUrl}" class="align-self-start mr-4 rounded-circle user-header" alt="用户头像" >
						</a>
						<div class="media-body">
							<div class="mt-0">
								<span class="font-size-12 text-success" th:utext="${cvo.user.username}">掉脑袋切切</span>
																					<!--xxxStat.count 是Thymeleaf隐藏的方法,指的是循环的次数-->
								<span class="badge badge-secondary float-right floor"><i th:text="${page.offset + cvoStat.count}">1</i>#</span>
							</div>
							<div class="mt-2" th:text="${cvo.comment.content}">
								这开课时间是不是有点晚啊。。。
							</div>
							<div class="mt-4 text-muted font-size-12">
								<span>发布于 <b th:text="${#dates.format(cvo.comment.createTime,'yyyy-MM-dd HH:mm:ss')}">2019-04-15 15:32:18</b></span>
								<ul class="d-inline float-right">
									<li class="d-inline ml-2"><a href="#" class="text-primary">赞(1)</a></li>
									<li class="d-inline ml-2">|</li>
									<li class="d-inline ml-2"><a href="#" class="text-primary">回复(<i th:text="${cvo.replyCount}">2</i>)</a></li>
								</ul>
							</div>
							<!-- 回复列表 -->
							<ul class="list-unstyled mt-4 bg-gray p-3 font-size-12 text-muted">
								<!-- 第1条回复 -->
								<li class="pb-3 pt-3 mb-3 border-bottom" th:each="rvo:${cvo.replys}">
									<div>
										<!--  如果有targetId就显示xx回复xxx  没有就显示xxx -->
										<span th:if="${rvo.target==null}">
											<b class="text-info" th:text="${rvo.user.username}">寒江雪</b>:&nbsp;&nbsp;
										</span>
										<span th:if="${rvo.target!=null}">
											<i class="text-info" th:text="${rvo.user.username}">Sissi</i> 回复
											<b class="text-info" th:text="${rvo.target.username}">寒江雪</b>:&nbsp;&nbsp;
										</span>
										<span th:text="${rvo.reply.content}">这个是直播时间哈，觉得晚的话可以直接看之前的完整录播的~</span>
									</div>
									<div class="mt-3">
										<span th:text="${#dates.format(rvo.reply.createTime,'yyyy-MM-dd HH:mm:ss')}">2019-04-15 15:32:18</span>
										<ul class="d-inline float-right">
											<li class="d-inline ml-2"><a href="#" class="text-primary">赞(1)</a></li>
											<li class="d-inline ml-2">|</li>
											<li class="d-inline ml-2"><a th:href="|#huifu-${rvoStat.count}|" data-toggle="collapse" class="text-primary">回复</a></li>
										</ul>
										<div th:id="|huifu-${rvoStat.count}|" class="mt-4 collapse">
											<div>
												<input type="text" class="input-size" placeholder="回复寒江雪"/>
											</div>
											<div class="text-right mt-2">
												<button type="button" class="btn btn-primary btn-sm" onclick="#">&nbsp;&nbsp;回&nbsp;&nbsp;复&nbsp;&nbsp;</button>
											</div>										
										</div>
									</div>								
								</li>

								<!-- 回复输入框 -->
								<li class="pb-3 pt-3">
									<div>
										<input type="text" class="input-size" placeholder="请输入你的观点"/>
									</div>
									<div class="text-right mt-2">
										<button type="button" class="btn btn-primary btn-sm" onclick="#">&nbsp;&nbsp;回&nbsp;&nbsp;复&nbsp;&nbsp;</button>
									</div>
								</li>
							</ul>
						</div>
					</li>

				</ul>
```



# 五. 添加评论--事务控制

## 1. 数据层

​	**--增加评论数据**

​	**--修改帖子的评论数量**



comment-mapper.xml

``` xml
<!--添加评论-->
    <insert id="insertComment" parameterType="com.justodit.entity.Comment">
        insert into comment(<include refid="insertComment"></include>)
        values(#{userId},#{entityType},#{entityId},#{targetId},#{content},#{status},#{createTime})
    </insert>
```



discusspost-mapper.xml

``` xml
 <!-- 再添加评论是,更新帖子的评论数量  -->
    <update id="updateCommentCount" parameterType="integer">
        update discuss_post set comment_count = #{commentCount} where id=#{id}
    </update>
```







## 2.业务层

​	**--处理添加评论的业务**

​		**先添加评论，再更新帖子的评论数量**



CommentService

``` java
@Service
public class CommentService  implements Constant {

    
     @Autowired
    private CommentMapper commentMapper;

    @Autowired
    private SensitiveFilter sensitiveFilter;

    @Autowired
    private DiscussPostService discussPostService;
    
      /**
     * 添加评论
     * @param comment  评论实体
     * @return
     */
    @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)
    public int addComment(Comment comment){

        if (comment == null){
            throw new IllegalArgumentException("参数不能为空");
        }

        //添加评论,过滤
        comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));
        comment.setContent(sensitiveFilter.filter(comment.getContent()));

        int rows = commentMapper.insertComment(comment);

        //更新帖子评论数量,只有评论给帖子的时候才更新,回复不更新
        if (comment.getEntityType() == ENTITY_TYPE_POST){
            int count = commentMapper.selectCountByEntity(comment.getEntityType(),comment.getEntityId());
            discussPostService.updateCommentCount(comment.getEntityId(),count);
        }


        return rows;


    }
```

DiscussPostService

``` java
 /**
     * 更新帖子的评论数量
     * @param id  帖子的id
     * @param commentCount  评论数量
     * @return
     */
    public int updateCommentCount(Integer id,Integer commentCount){
        return discussPostMapper.updateCommentCount(id,commentCount);
    }
```





## 3. 表现层



**--处理添加评论数据的请求**

**--设置添加评论的表单**



CommentController

``` java
@Controller
@RequestMapping("/comment")
public class CommentController {


    @Autowired
    private CommentService commentService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(value = "/add/{discussPostId}",method = RequestMethod.POST)
    public String addComment(@PathVariable("discussPostId")int discussPostId, Comment comment){


        comment.setUserId(hostHolder.getUser().getId());//评论人的id
        comment.setStatus(0);
        comment.setCreateTime(new Date());
        if (comment.getTargetId()==null){
            comment.setTargetId(0);
        }
        commentService.addComment(comment);

        //跳转到帖子详情页面
        return "redirect:/discuss/detail/" + discussPostId;


    }

}
```



## 4.页面

``` java
<!-- 回帖列表 -->
				<ul class="list-unstyled mt-4">
					<li class="media pb-3 pt-3 mb-3 border-bottom" th:each="cvo:${comments}">
						<a href="profile.html">
							<img th:src="${cvo.user.headerUrl}" class="align-self-start mr-4 rounded-circle user-header" alt="用户头像" >
						</a>
						<div class="media-body">
							<div class="mt-0">
								<span class="font-size-12 text-success" th:utext="${cvo.user.username}">掉脑袋切切</span>
																					<!--xxxStat.count 是Thymeleaf隐藏的方法,指的是循环的次数-->
								<span class="badge badge-secondary float-right floor"><i th:text="${page.offset + cvoStat.count}">1</i>#</span>
							</div>
							<div class="mt-2" th:text="${cvo.comment.content}">
								这开课时间是不是有点晚啊。。。
							</div>
							<div class="mt-4 text-muted font-size-12">
								<span>发布于 <b th:text="${#dates.format(cvo.comment.createTime,'yyyy-MM-dd HH:mm:ss')}">2019-04-15 15:32:18</b></span>
								<ul class="d-inline float-right">
									<li class="d-inline ml-2"><a href="#" class="text-primary">赞(1)</a></li>
									<li class="d-inline ml-2">|</li>
									<li class="d-inline ml-2"><a href="#" class="text-primary">回复(<i th:text="${cvo.replyCount}">2</i>)</a></li>
								</ul>
							</div>
							<!-- 回复列表 -->
							<ul class="list-unstyled mt-4 bg-gray p-3 font-size-12 text-muted">
								<!-- 第1条回复 -->
								<li class="pb-3 pt-3 mb-3 border-bottom" th:each="rvo:${cvo.replys}">
									<div>
										<!--  如果有targetId就显示xx回复xxx  没有就显示xxx -->
										<span th:if="${rvo.target==null}">
											<b class="text-info" th:text="${rvo.user.username}">寒江雪</b>:&nbsp;&nbsp;
										</span>
										<span th:if="${rvo.target!=null}">
											<i class="text-info" th:text="${rvo.user.username}">Sissi</i> 回复
											<b class="text-info" th:text="${rvo.target.username}">寒江雪</b>:&nbsp;&nbsp;
										</span>
										<span th:text="${rvo.reply.content}">这个是直播时间哈，觉得晚的话可以直接看之前的完整录播的~</span>
									</div>
									<div class="mt-3">
										<span th:text="${#dates.format(rvo.reply.createTime,'yyyy-MM-dd HH:mm:ss')}">2019-04-15 15:32:18</span>
										<ul class="d-inline float-right">
											<li class="d-inline ml-2"><a href="#" class="text-primary">赞(1)</a></li>
											<li class="d-inline ml-2">|</li>
											<li class="d-inline ml-2"><a th:href="|#huifu-${rvoStat.count}|" data-toggle="collapse" class="text-primary">回复</a></li>
										</ul>
										<!--回复类xxx  有targetId-->
										<div th:id="|huifu-${rvoStat.count}|" class="mt-4 collapse">
											<form th:action="@{|/comment/add/${post.id}|}" method="post">
												<div>
													<input type="text" class="input-size"  name="content" th:placeholder="|回复${rvo.user.username}|"/>
													<input type="hidden" name="entityType" value="2">
													<input type="hidden" name="entityId" th:value="${cvo.comment.id}">
													<input type="hidden" name="targetId" th:value="${rvo.user.id}">
												</div>
												<div class="text-right mt-2">
													<button type="submit" class="btn btn-primary btn-sm" onclick="#">&nbsp;&nbsp;回&nbsp;&nbsp;复&nbsp;&nbsp;</button>
												</div>
											</form>

										</div>
									</div>								
								</li>

								<!-- 回复输入框   无targetId  回复给评论的-->
								<li class="pb-3 pt-3">
									<form  th:action="@{|/comment/add/${post.id}|}" method="post">
										<div>
											<input type="text" class="input-size"  name="content" placeholder="请输入你的观点"/>
											<input type="hidden" name="entityType" value="2">
											<input type="hidden" name="entityId" th:value="${cvo.comment.id}">
										</div>
										<div class="text-right mt-2">
											<button type="submit" class="btn btn-primary btn-sm" onclick="#">&nbsp;&nbsp;回&nbsp;&nbsp;复&nbsp;&nbsp;</button>
										</div>
									</form>
								</li>
							</ul>
						</div>
					</li>
```





# 六、私信列表

![image-20200825225838184](imgaes/image-20200825225838184.png)

​	**from_id 为1的话代表系统消息**

​	conversation_id 会话id是根据from_id 和to_id 拼接而成

​	小的id在前，大的id灾后  如 111--->  112    111——112   ,   112--->111     111_112

![image-20200826105614466](imgaes/image-20200826105614466.png)

## 1.私信列表



**--查询当前用户的会话列表，**

​	**每个会话只显示一条最新的私信。**

**--支持分页显示。**

### 1.0 Entity

``` java
package com.justodit.entity;

import java.security.Principal;
import java.util.Date;

public class Message {

    private Integer id;
    private Integer fromId;   //发送者id
    private Integer toId;    //接收者id
    private String conversationId;   //会话id
    private String content;    //会话内容
    private  Integer status;   //会话状态  0已读   1未读   2删除
    private Date createTime;  //创建时间

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getFromId() {
        return fromId;
    }

    public void setFromId(Integer fromId) {
        this.fromId = fromId;
    }

    public Integer getToId() {
        return toId;
    }

    public void setToId(Integer toId) {
        this.toId = toId;
    }

    public String getConversationId() {
        return conversationId;
    }

    public void setConversationId(String conversationId) {
        this.conversationId = conversationId;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return "Message{" +
                "id=" + id +
                ", fromId=" + fromId +
                ", toId=" + toId +
                ", conversationId='" + conversationId + '\'' +
                ", content='" + content + '\'' +
                ", status=" + status +
                ", createTime=" + createTime +
                '}';
    }
}

```





### 1.1 Mapper

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.justodit.dao.CommentMapper">

    <sql id="selectFields">
        id, user_id, entity_type, entity_id, target_id, content, status, create_time
    </sql>
    <sql id="insertComment">
         user_id, entity_type, entity_id, target_id, content, status, create_time
    </sql>

<!--    查询评论-->
    <select id="selectCommentByEntity" resultType="com.justodit.entity.Comment" parameterType="integer">
        select <include refid="selectFields"></include>
        from comment
        where status=0
        and entity_type=#{entityType}
        and entity_id=#{entityId}
        order by create_time asc
        limit #{offset}, #{limit}
    </select>

<!--    查询总评论数-->
    <select id="selectCountByEntity" resultType="integer" parameterType="integer">
        select count(*)
        from comment
        where status=0
        and entity_type=#{entityType}
        and entity_id = #{entityId}
    </select>

    <!--添加评论-->
    <insert id="insertComment" parameterType="com.justodit.entity.Comment">
        insert into comment(<include refid="insertComment"></include>)
        values(#{userId},#{entityType},#{entityId},#{targetId},#{content},#{status},#{createTime})
    </insert>

</mapper>
```



``` java
package com.justodit.dao;

import com.justodit.entity.Comment;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface CommentMapper {


    /**
     * 查询评论
     * @param entityType 评论类型
     * @param entityId  帖子的id
     * @param offset   开始
     * @param limit   结束
     * @return
     */
    List<Comment> selectCommentByEntity(int entityType,int entityId,int offset,int limit);


    /**
     * 帖子评论的数量
     * @param entityType  评论类型  评论or回复
     * @param entityId
     * @return
     */
    int selectCountByEntity(int entityType,int entityId);


    /**
     * 添加评论
     * @param comment
     * @return
     */
    int insertComment(Comment comment);
}

```



### 1.2 Service

``` java
package com.justodit.service;

import com.justodit.dao.MessageMapper;
import com.justodit.entity.Message;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.naming.LimitExceededException;
import java.util.List;

@Service
public class MessageService {


    @Autowired
    private MessageMapper messageMapper;

    //查询当前用户的所有会话列表
    public List<Message> findConversations(int  userId,int offset,int limit){
        return messageMapper.selectConversations(userId,offset,limit);
    }

    //查询当前用户会话数量
    public int findConversationCount(int userId){
        return messageMapper.selectConversationCount(userId);
    }

    //查询私信详情
    public List<Message> findLetters(String conversationId,int offset ,int limit){
        return messageMapper.selectLetters(conversationId,offset,limit);
    }

    //查询一个会话私信的数量
    public int findLetterCount(String conversationId){
        return messageMapper.selectLetterCount((conversationId));
    }

    //查询未读消息数
    public int findLetterUnreadCount(int userId,String conversationId){
        return messageMapper.selectLetterUnreadCount(userId,conversationId);
    }

}

```



### 1.4 Controller

``` java
package com.justodit.controller;

import com.justodit.entity.Message;
import com.justodit.entity.Page;
import com.justodit.entity.User;
import com.justodit.service.MessageService;
import com.justodit.service.UserService;
import com.justodit.util.HostHolder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class MessageController {

    @Autowired
    private MessageService messageService;

    @Autowired
    private HostHolder hostHolder;

    @Autowired
    private UserService userService;

    /**
     * 会话列表
     * @param model
     * @param page
     * @return
     */
    @GetMapping("/letter/list")
    public String getLetterList(Model model, Page page){

        User user = hostHolder.getUser();

        //设置分页信息
        page.setLimit(5);
        page.setPath("/letter/list");
        page.setRows(messageService.findConversationCount(user.getId()));
        //所有会话列表
        List<Message> conversationList = messageService.findConversations(user.getId(), page.getOffset(), page.getLimit());

        List<Map<String,Object>> conversations = new ArrayList<>();
        if (conversationList != null){
            for (Message message : conversationList) {
                Map<String,Object> map = new HashMap<>();
                map.put("conversation",message);
                map.put("letterCount",messageService.findLetterCount(message.getConversationId()));
                map.put("unreadCount",messageService.findLetterUnreadCount(user.getId(),message.getConversationId()));
                //显示对方头像   如果是我发起的会话,对方就是to   如果是对方发起的会话,对方就是from
                int targetId = user.getId() == message.getFromId() ? message.getToId():message.getFromId();
                map.put("target",userService.findUserById(targetId));

                conversations.add(map);
            }
        }

        model.addAttribute("conversations",conversations);

        //查询未读消息数量,所有会话
        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(),null);
        model.addAttribute("letterUnreadCount",letterUnreadCount);

        return "/site/letter";
    }

    /**
     *  会话详情
     * @param conversationId
     * @param page
     * @param model
     * @return
     */
    @GetMapping("/letter/detail/{conversationId}")
    public String getLetterDetail(@PathVariable("conversationId") String conversationId,Page page,Model model){
        //分页信息
        page.setLimit(5);
        page.setPath("/letter/detail/"+conversationId);
        page.setRows(messageService.findLetterCount(conversationId));

        //私信列表
        List<Message> letterList = messageService.findLetters(conversationId,page.getOffset(),page.getLimit());
        List<Map<String,Object>> letters = new ArrayList<>();
        if (letterList != null){
            for (Message message : letterList) {
                Map<String,Object> map = new HashMap<>();
                map.put("letter",message);
                map.put("fromUser",userService.findUserById(message.getFromId()));

                letters.add(map);
            }
        }

        model.addAttribute("letters",letters);

        //查询私信目标
        model.addAttribute("target",getLetterTarget(conversationId));

        return "/site/letter-detail";
    }

    private User getLetterTarget(String conversationId){
        String[] ids = conversationId.split("_");
        int id0 = Integer.parseInt(ids[0]);
        int id1 = Integer.parseInt(ids[1]);

        if (hostHolder.getUser().getId() == id0){
            return userService.findUserById(id1);
        }else{
            return userService.findUserById(id0);
        }
    }
}

```



### 1.5 页面



``` html
<!-- 私信列表 -->
				<ul class="list-unstyled">
					<li class="media pb-3 pt-3 mb-3 border-bottom position-relative" th:each="map:${conversations}">
						<span class="badge badge-danger" th:text="${map.unreadCount}" th:if="${map.unreadCount != 0} ">3</span>
						<a href="profile.html">
							<img th:src="${map.target.headerUrl}" class="mr-4 rounded-circle user-header" alt="用户头像" >
						</a>
						<div class="media-body">
							<h6 class="mt-0 mb-3">
								<span class="text-success" th:utext="${map.target.username}">落基山脉下的闲人</span>
								<span class="float-right text-muted font-size-12" th:text="${#dates.format(map.conversation.createTime,'yyyy-MM-dd')}">2019-04-28 14:13:25</span>
							</h6>
							<div>
								<a th:href="@{|/letter/detail/${map.conversation.conversationId}|}" th:utext="${map.conversation.content}">米粉车, 你来吧!</a>
								<ul class="d-inline font-size-12 float-right">
									<li class="d-inline ml-2"><a href="#" class="text-primary" >共<i th:text="${map.letterCount}">5</i>条会话</a></li>
								</ul>
							</div>
						</div>
```



## 2. 私信详情

​	**--查询某个会话包含的私信**

​	**--支持分页查询**

mapper  service 都在前面写过了

``` java
/**
     *  会话详情
     * @param conversationId
     * @param page
     * @param model
     * @return
     */
    @GetMapping("/letter/detail/{conversationId}")
    public String getLetterDetail(@PathVariable("conversationId") String conversationId,Page page,Model model){
        //分页信息
        page.setLimit(5);
        page.setPath("/letter/detail/"+conversationId);
        page.setRows(messageService.findLetterCount(conversationId));

        //私信列表
        List<Message> letterList = messageService.findLetters(conversationId,page.getOffset(),page.getLimit());
        List<Map<String,Object>> letters = new ArrayList<>();
        if (letterList != null){
            for (Message message : letterList) {
                Map<String,Object> map = new HashMap<>();
                map.put("letter",message);
                map.put("fromUser",userService.findUserById(message.getFromId()));

                letters.add(map);
            }
        }

        model.addAttribute("letters",letters);

        //查询私信目标
        model.addAttribute("target",getLetterTarget(conversationId));

        return "/site/letter-detail";
    }

    private User getLetterTarget(String conversationId){
        String[] ids = conversationId.split("_");
        int id0 = Integer.parseInt(ids[0]);
        int id1 = Integer.parseInt(ids[1]);

        if (hostHolder.getUser().getId() == id0){
            return userService.findUserById(id1);
        }else{
            return userService.findUserById(id0);
        }
    }
```



``` html
				<!-- 私信列表 -->
				<ul class="list-unstyled mt-4">
					<li class="media pb-3 pt-3 mb-2" th:each="map:${letters}">
						<a href="profile.html">
							<img th:src="${map.fromUser.headerUrl}" class="mr-4 rounded-circle user-header" alt="用户头像" >
						</a>
						<div class="toast show d-lg-block" role="alert" aria-live="assertive" aria-atomic="true">
							<div class="toast-header">
								<strong class="mr-auto" th:utext="${map.fromUser.username}">落基山脉下的闲人</strong>
								<small th:text="${#dates.format(map.letter.createTime,'yyyy-MM-dd')}">2019-04-25 15:49:32</small>
								<button type="button" class="ml-2 mb-1 close" data-dismiss="toast" aria-label="Close">
									<span aria-hidden="true">&times;</span>
								</button>
							</div>
							<div class="toast-body" th:utext="${map.letter.content}">
								君不见, 黄河之水天上来, 奔流到海不复回!
							</div>
						</div>
					</li>

				</ul>
```



# 七、发送私信--Ajax

![image-20200831195453927](imgaes/image-20200831195453927.png)

![image-20200831195517580](imgaes/image-20200831195517580.png)

![image-20200831200538548](imgaes/image-20200831200538548.png)

## 1.发送私信

​		**--采用异步的方式发送私信**

​		**--发送成功后刷新私信列表。**



### 1.1Mapper,xml

``` java
    /**
     * 发送   新增 消息
     * @param message
     * @return
     */
    int insertMessage(Message message);

    /**
     * 修改消息的状态
     * @param ids  要修改已读消息的id
     * @param status  要修改成的状态 0已读   1未读   2删除
     * @return
     */
    int updateStatus(List<Integer> ids,int status);
```



``` xml
    <!--    发送 增加消息-->
    <insert id="insertMessage" parameterType="com.justodit.entity.Message" keyProperty="id" keyColumn="id">
            insert into message(<include refid="insertFileds"></include>)
            values(#{fromId},#{toId},#{conversationId},#{content},#{status},#{createTime})
    </insert>

    <!-- 修改消息状态  已读   -->
    <update id="updateStatus">
        update message set status = #{status}
        where id in
        <foreach collection="ids" item="id" open="(" separator="," close=")">
            #{id}
        </foreach>
    </update>

```



### 1.2 MessageService



``` java
 //添加一条消息
    public int addMessage(Message message){

        message.setContent(HtmlUtils.htmlEscape(message.getContent()));
        //过滤敏感词
        message.setContent(sensitiveFilter.filter(message.getContent()));
        return messageMapper.insertMessage(message);
    }

    //更新消息为已读
    public int readMessage(List<Integer> ids){
        return messageMapper.updateStatus(ids,1);
    }
```



### 1.3 MessageController



```java
 /**
     * 发送私信
     * @param toName  发送给谁的用户名
     * @param content  发送的内容
     * @return
     */
    @PostMapping("/letter/send")
    @ResponseBody
    public String sendLetter(String toName,String content){
        User target = userService.findUserByName(toName);
        if (target == null){
            return JustDoItUtil.getJsonString(1,"目标用户不存在");
        }
        Message message = new Message();
        message.setFromId(hostHolder.getUser().getId());
        message.setToId(target.getId());
        //拼接conversationId  小Id_大id
        if (message.getFromId() < message.getToId()){
            message.setConversationId(message.getFromId()+"_"+message.getToId());
        }else {
            message.setConversationId(message.getToId()+"_"+message.getFromId());
        }
        message.setContent(content);
        message.setStatus(0);
        message.setCreateTime(new Date());

        messageService.addMessage(message);
        return JustDoItUtil.getJsonString(0);


    }
```



### 1.4 页面



``` js
//发送私信
$(function(){
	$("#sendBtn").click(send_letter);
	$(".close").click(delete_msg);
});

function send_letter() {
	//关闭发送框
	$("#sendModal").modal("hide");

	//发送数据 异步
	var toName = $("#recipient-name").val();
	var content = $("#message-text").val();

	$.post({
		url:"/letter/send",
		data:{"toName":toName,"content":content},
		success:function (data) {
			//将json转换为js对象
			data = $.parseJSON(data);
			if (data.code == 0){
				$("#hintBody").text("发送成功");
			}else {
				$("#hintBody").text(data.msg);
			}


			//显示提示框
			$("#hintModal").modal("show");
			setTimeout(function(){
				$("#hintModal").modal("hide");
				//刷新页面
				location.reload();
			}, 2000);

		}
	});


}

function delete_msg() {
	// TODO 删除数据
	$(this).parents(".media").remove();
}
```



## 2.设置已读

​		**--访问私信详情时，将显示的私信设置为已读状态。**



​	**思路：当消息接收者查看消息详情时，将消息的状态设置为已读**

![image-20200831200315532](imgaes/image-20200831200315532.png)

![image-20200831200047760](imgaes/image-20200831200047760.png)





# 八、统一处理异常--@ControllerAdvice

![image-20200831210452955](imgaes/image-20200831210452955.png)

![image-20200831210530362](imgaes/image-20200831210530362.png)



``` java
package com.justodit.controller.advice;

import com.justodit.util.JustDoItUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

//异常处理
@ControllerAdvice(annotations = Controller.class)//只扫描带有Controller注解的类
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    @ExceptionHandler({Exception.class})
    public void handlerException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error("服务器发生异常"+e.getMessage());
        for (StackTraceElement element :e.getStackTrace()){
            logger.error(element.toString());
        }

        //判断请求的方式
        String xRequestedWith = request.getHeader("x-requested-with");//固定写法
        if ("XMLHttpRequest".equals(xRequestedWith)){
            //是异步请求
            response.setContentType("application/plain;charset=utf-8");  //返回普通字符串,在页面上手动转为json $.parseJSON

            PrintWriter writer = response.getWriter();
            writer.write(JustDoItUtil.getJsonString(1,"服务器异常"));

        }else {
            //不是异步请求,重定向到500页面
            response.sendRedirect(request.getContextPath()+"/error");
        }
    }

}

```





# 九、统一记录日志--AOP

![image-20200831213940699](imgaes/image-20200831213940699.png)



![image-20200831213821660](imgaes/image-20200831213821660.png)

**Joinpoint( 连接点):**
		所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。
**Pointcut( 切入点):**
	所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。
**Advice( 通知/ 增强):**
	所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。
	通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。
**Introduction( 引介):**
	引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。
**Target( 目标对象):**
	代理的目标对象。
**Weaving( 织入):**
	是指把增强应用到目标对象来创建新的代理对象的过程。
	spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。
**Proxy （代理）:**
	一个类被 AOP 织入增强后，就产生一个结果代理类。
**Aspect( 切面):**
	是切入点和通知（引介）的结合。





``` java
package com.justodit.aspect;

//日志记录
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import javax.servlet.http.HttpServletRequest;
import java.text.SimpleDateFormat;
import java.util.Date;

@Component
@Aspect
public class ServiceLogAspect {

    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    //切入点
    @Pointcut("execution(* com.justodit.service.*.*(..))")
    public void pointcut(){

    }

    @Before("pointcut()")
    public void before(JoinPoint joinPoint){
        //用户[1.2.3.4],在xxx时间,访问了[com.justodit.service.xxxx()];
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
            //getDeclaringTypeName()类名                      getName() 方法名
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        logger.info(String.format("用户[%s],在[%s],访问了[%s].",ip,now,target));
    }
}

```

